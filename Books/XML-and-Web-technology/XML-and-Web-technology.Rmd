---
title: "XML-and-Web-technology"
author: "yincy"
date: "7/2/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE}
library(XML)
library(rjson)
library(tidyverse)
```


# Chapter 1 Getting Started with XML and JSON  
## Reading from HTMLTables  
```{r}
u <- "/home/yincy/git/R-codes/Books/XML-and-Web-technology/files/List of countries and dependencies by population - Wikipedia.html"
tbls <- readHTMLTable(doc = u)
tbls %>% class()
```

```{r}
sapply(tbls, names)
sapply(tbls, nrow) # the large table is the population table
```

```{r}
pop <- readHTMLTable(doc = u, 
                     which = 1, 
                     header = T)
colnames(pop) <- c("Rank", "Country", "Population", "Percentage", "Date", "Source")
pop %>% head()
```


For each <table> node, `readHTMLTable()` loops over the row nodes (<tr>) and processes each cell in the row. These cells are either <th> or <td> elements for header or regular data, respectively.  

The data are typically in <td> elements, and we simply extract the contents of each cell as string.  

The <th> elements in a table typically indicate column header, and is used for variable names when appropriate.  


# Chapter 3 Parsing XML Content  
```{r}
doc <- xmlParse("Data/Kiva/lenders/")
lenderNode <- xmlRoot(doc)[["lenders"]]
occ <- sapply(xmlChildren(lenderNode), function(node) {
    xmlValue(node[["occupation"]])
}) %>% table() %>% sort(decreasing = T)
```


```{r}
doc <- xmlParse(file = "Data/merged_catalog.xml.gz")
root <- xmlRoot(x = doc)
xmlName(root)
```

```{r}
root %>% xmlSize()
```

```{r}
xmlChildren(root) %>% length()
```

```{r}
event1 <- root[["event"]]
event1
```

```{r}
event1[[10]] %>% xmlAttrs() %>% .["value"]
```

```{r}
root[1:3]
```

```{r}
evs <- root["event"]
length(evs)
root[names(root) == "event"]
```


```{r}
names(event1) # node names of the child elements
```

```{r}
xmlName(event1) # node names of the node itself
``` 

```{r}
doc <- xmlParse(file = "Data/Kiva/lenders/1.xml")
lenderNode <- xmlRoot(doc)[["lenders"]]
xmlSize(lenderNode)
```

```{r}
lenderNode
lenderNode[[1]][c("name", "occupation", "image", "country_code")]
```

```{r}
lenderNode[[1]][c("name", "image", "whereabouts", "country_code")]
```

```{r}
w <- sapply(xmlChildren(lenderNode[[1]]), xmlSize) > 1
lenderNode[[1]][w]
```


```{r}
doc <- xmlParse(file = "Data/merged_catalog.xml.gz")
root <- xmlRoot(x = doc)

timests <- xmlSApply(X = root, xmlGetAttr, name = "time-stamp")
timests %>% class()
timests[[1]]
```

```{r}
xmlSApply(X = root, xmlGetAttr, name = "id")
```

```{r}
child10 <- xmlSApply(root, "[[", 10) %>% sapply(X = ., xmlGetAttr, name = "value")
names(child10) <- NULL
table(child10) %>% barplot()
```

```{r}
xmlSApply(root, xmlSize)[1:4]
```

more general approch to ge magnitude  
```{r}
mags <- xmlSApply(root, function(evNode){
    parNames = xmlSApply(evNode, xmlGetAttr, "name")
    i = which(parNames == "magnitude")
    xmlGetAttr(evNode[[i]], name = "value")
})
```

```{r}
mags <- getNodeSet(doc = root, 
           path = "/merge/event/param[@name='magnitude']/@value") %>% 
    unlist() %>% 
    as.numeric()

time_stamp <- getNodeSet(doc = root, 
                         path = "/merge/event[@version = '1']") %>% 
    xmlSApply(xmlGetAttr, name = "time-stamp")

mags %>% table() %>% barplot()
```


```{r}
# do not lost access to the parent even though we assigned this node to a new variable.  
firstMag <- root[[1]][[10]]

getSibling(node = firstMag, after = T)
```


```{r}
xmlParent(firstMag) %>% getSibling(after = TRUE) %>% xmlAttrs()
```


```{r}
xmlAncestors(x = firstMag)[[1]] %>% xmlName()
```

```{r}
firstMag %>% xmlParent() %>% getSibling(after = T) %>% .[[10]]
```

```{r}
root[2]
```


**The DOM Parser in R**  

read the XML document into R  
```{r}
doc <- xmlParse(file = "Data/sampleDoc.xml")
```

Access the root node  
```{r}
root <- xmlRoot(x = doc)
```

Operate on a node as if it is a list of its children, i.e. use `[` and `[[` to access elements in the tree.  
```{r}
node3_1 <- root[[3]][[1]]
node3_1 <- root[["section"]][["para"]]
```

The `XML` package provides functions for determining information about a node. These include `xmlName()`, `xmlSize()`, `xmlAttrs()`, `xmlGetAttr()`, `xmlValue`, `xmlNamespace()` and `getDefaultNamespace()`, which provide, in order, the node's name, number of children, attributes, a specific attribute, text content of the node and its descendants, namespace, and defualt namespace.  
```{r}
root[["title"]] %>% xmlValue()
root[["section"]] %>% xmlValue()
```

In addition to `[` and `[[`, other functions in XML enables us to work with a node's aiblings, children, parent and acncestors. These are `getSibling()`, `xmlChildren()`, `xmlParent()`, and `xmlAncestors()`, respectively.  
```{r}
node3_1 %>% xmlParent()
```

```{r}
getSibling(node = root[[2]])
```

```{r}
node3_1 %>% xmlParent() %>% xmlParent() %>% .[[1]]

# equal to the root[[1]]
root[[1]]
```

```{r}
node3_1 %>% xmlParent() %>% getSibling(after = F) %>% getSibling(after = F)
```

The tree object behaves differently from regular R objects. When we make the assignment, `node3_1 == root[[3]][[1]]`, we now have a reference to that point in the tree. Any operations on `node3_1` will be made to the tree as well.  
```{r}
node3_1 = root[[3]][[1]]
node3_1 %>% xmlParent() %>% xmlParent()
```


## Parsing Other XML Element Types  
```{r}
rdbRoot <- xmlParse(file = "Data/sampleDoc.xml") %>% xmlRoot()

rdbRoot[[2]]
```

```{r}
rdbRoot[[2]] %>% xmlValue()
```

The `xmlValue()` function is generic so it it works on different types of nodes. For nodes that are mixtures of text content and other nodes, `xmlValue()` returns a character string that concatenates the text content of all the node's descendants.  
```{r}
rdbRoot[[3]][[1]] %>% names()
```

```{r}
rdbRoot[[3]][[1]] %>% 
    xmlChildren() %>% 
    sapply(class)
```

```{r}
rdbRoot[[3]][[1]] %>% 
    xmlSApply(xmlValue)
```

```{r}
rdbRoot[[3]][[1]] %>% 
    xmlNamespace()


rdbRoot[[3]][[1]] %>% 
    getDefaultNamespace()
```


## Reading XML from Different Input Sources  
The parser available through the `XML` package supports reading local files, in-memory XML strings, URLs, and 'local' compressed files.  
```{r}
xmlParse(file = "https://sports.sohu.com/s/nba", isHTML = T)
```

 
```{r}
getEncoding(obj = rdbRoot)
```


# Chapter 4 XPath, XPointer, and XInclude  
```{r}
doc <- htmlParse(file = "http://www.bioconductor.org/packages/release/bioc/vignettes/TCGAbiolinks/inst/doc/subtypes.html")
listOfNodes <- getNodeSet(doc = doc, path = "//a[@href]")
```

```{r}
xpathSApply(doc, path = "//a[@href]", fun = xmlGetAttr, name = "href") %>% head()
```

```{r}
getNodeSet(doc, path = "//a/@href") %>% .[10:20]
```


```{r}
mil <- xmlParse(file = "files/sweat_metabolites.xml")

mol <- getNodeSet(doc = mil, path = "/*/metabolite/accession/text()")
xpexpr <- ".//metabolite/accession/text()"
lapply(mil, function(node) xpathSApply(node, xpexpr, xmlValue))
```


## XPath and the XML Tree  
```{r}
doc <- xmlParse(file = "Data/eurofxref-hist.xml")
root <- xmlRoot(x = doc)
root %>% xmlSize()
```

```{r}
xpexpr <- "/Envelope/Sender/name"
nm <- getNodeSet(doc = root, path = xpexpr)
nm %>% xmlToDataFrame()
```

```{r}
mn <- getNodeSet(doc = root, path = "//Cube[@currency = 'JPY']")
mn %>% xmlToDataFrame()
```

```{r}
getNodeSet(doc = doc, path = "//Cube[@currency = 'CZK' and @rate < 25]")
```


## XPath Syntax  
An XPath expression is made up of one or more location steps, separated by a / character. An individual location step has three distinct parts, the axis, node-test, and an optional predicate, which we specify in the following format:  
```
axis::node-test[predicate]
```

### The Axis  
The axis provides both the direction to look for nodes (from the current context) and also how to look along that direction. Directions are expressed using the family relationship terminology from the document hierarchy, e.g., child, parent, sibling, ancestor, desendant.  

The `child` axis looks down the tree one level (from the current location or context) to the immediate child nodes.  

The `parent` and `ancestor` axes look up the node while the `ancestor` looks at the parent node, the parent's parent, and so on up to the root node.  

The ancestor-or-self axis considers all the ancestor as well as the current node (the current node is the `self` axis).  

Similarly, `descendant` and `descendant-or-self` work on descendant elements in the tree.  

The `preceding-sibling` and `following-sibling` look along the same level of the current context at all of the preceding siblings (to the left) and the following siblings (to the right), respectively.  


#### Axis Shortcuts and Abbreviations  
Some axes are very common so there are shortcuts for these that make the XPath expression more succinct and clearer to read. These shortcuts can be used in a location step within the location path. The most common axis is child. This is the default axis and can be omitted from any XPath step.  

Another commonly used abbreviation is the double forward slash `//` which is shorthand for the axis `descendant-or-self`.  

```
/child::Envelope/child::Cube/child::Cube/child::Cube
```

It can also be writen as  
```
/Envelope/Cube/Cube/Cube
```

```{r}
root <- xmlRoot(mil)

root %>% xmlSize()
root %>% xmlSApply(xmlValue)
getNodeSet(doc, "//Envelope")
```


#### The Node Test  
The node-test component in a location step identifies the name or the type of node to be matched. This is often just simply the name of the nodes in which we are interested, e.g., Cube, Sender, or molecule.  

At times we want to match a node with any name, and not a specific fixed name. In this case we can use the asterisk (*) as a wildcard that matches all named elements.  

The * symbol is realy shorthand for the `node()` function that matches any regular node, i.e., it does not match text, comments, attributes, and processing instructions.  

If we want to match text nodes we use the node-test `text().  

Similarly, we use `comment()` to match comments and `processing-instruction()` to match any processing instruction.   

If we want to match only processing instructions with a particular target, we pass the target name as a string in the call to `processing-instruction()`.  
```
//processing-instruction('R')
```

#### The Predicate  
Predicates allow us to further restrict the node-set, but they are not always needed and so can be omitted. A predicate tests each of the candidate nodes matched by the node-test part of the location step.  

**The XPath Location-step**  
XPath locates sets of nodes in XML documents. An XPath expression is a location path that is made up of one or more location steps. Each step has two required parts - the axis and node-test - and an optional predicate as the third part. The location step follows the syntax:  
```
axis::node-test[predicate]
```

The location step can be thought of as directions from one location (or context) to another. The direction is relative to each node in the current set of nodes, as computed by the previous step.  

The step indicates which direction to look (axis), the ndoe(s) name or type to locate (node-test), and the filter or subset condition to apply to the qualifying nodes (predicate).  

XPath ignores white space (blank spaces and new lines) within a location step and betwen steps which allows us to format the expressions freely.  

- `axis::` Orients the search and is expressed in the vocabulary of a tree hierarchy, e.g., `child` looks at the children of the current context, `parent` looks at the oarent, and `descendant-orself` looks at the current context and all nodes that descend from it. These axes are often abbreviated. For example, the `child` axis is the default and can be omitted entirely from the location step. Also, `descendant-or-self::foo` can be abbreviated to `//foo` and `attribute::name` can be expressed as `@name`. We can refer to the current node and the parent with `.` and `..`, rather than `self::node()` and `parent::node()`, respectively.  

- `node-test` Provides the element name or an element type to locate in the location step. For element with no names, e.g., text and comments, we use functions, such as `text()` and `comment()` to locate element by type. We can use the generic `node()` function to identity any regular/named node. The wildcard shortcut `*` also matches any regular node.  

- `[predicate]` This part of the location step operate on the nodes matching the `axis::node-test` and filters the qualifying nodes to those that meet the conditions of the predicate. The expression in the predicate is applied to each node in the node-test and if the result is `true`, the node remains in the node-set. XPath provides many functions to use in the predicate. For example, `[position() = last()]` keeps only the last node in the node-set; this can be abbreviated to `[last()`. Similary, we can subset by position, e.g., `//section[2]` yields the second <section> node. There are functions to compute the name or value of a node and also to perform string manipulation and comparisions. Simple expressions can be combined using the `and` & `or` operators.  
```
//Cube[currency = 'USD' or @rate > 1.5]

/descendant-or-self::Cube[@time]/child::Cube[attribute::rate<25]
```

More than one element can be located by an XPath expression. The located nodes are called the `node-set`. Each matching node appears in the node-set just once. This is useful and especially important to remember when we work with compound XPath queries.  


## XPath Functions and Logical Operators  
XPath provides logical operators for combining predicates. Predicates can be combined together into a compound predicate using one of the binary operators `and` or `or`.  

```{r}
doc <- xmlParse(file = "Data/eBay/tt.xml")
root <- xmlRoot(doc)

getNodeSet(doc, path = "/svg/circle")
val %>% length()
val[[1]] %>% head()
```





```{r}
doc <- xmlParse(file = "Data/merged_catalog.xml.gz")
xmlSApply(doc %>% getNodeSet("/merge/event[@version = '1']"), xmlGetAttr, name = "network-code") %>% 
    table() %>% 
    sort() %>% 
    barplot()
```


```{r}
doc <- xmlParse(file = "Data/Kiva/lenders/1.xml")
xmlSApply(doc %>% getNodeSet(path = "/snapshot/lenders/lender/country_code"), xmlValue) %>% table() %>% as.data.frame() %>% 
    ggplot(aes(reorder(., Freq), Freq)) +
    geom_bar(stat = "identity") +
    theme(axis.text.x = element_text(hjust = 0.5, angle = 0, size = 7)) +
    scale_x_discrete(name = "lenders") +
    geom_text(aes(label = Freq, y = Freq + 30), color = "blue")
```




