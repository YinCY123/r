---
title: "02 colwise operation"
author: "yincy"
date: "2023-01-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


It's often useful to perform the same operation on multiple columns, but copying and pasting is both tedious and error prone. 

```{r}
library(dplyr)
```


## Basic usage
`across()` has two primary arguments:  

- The first argument, `cols`, selects the columns you want to operate on. It uses tidy selection (like `select()`) so you can pick variables by position, name, and type.  

- The second argument, `.fns`, is a function or list of functions to apply to each column. This can also be a purrr style formula (or list of formulas) like `~ .x/2`. (This argument  is optional, and you can omit it if you just want to get the underlying data).  

```{r}
starwars %>% 
    summarise(across(where(is.character), n_distinct))


starwars %>% 
    group_by(species) %>% 
    filter(n() > 1) %>% 
    summarise(across(c(sex, gender, homeworld), n_distinct))


starwars %>% 
    group_by(homeworld) %>% 
    filter(n() > 1) %>% 
    summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)))
```

## Multiple functions
You can transform each variable with more than one function by supplying a named list of functions or lambda functions in the second argument.  

```{r}
min_max <- list(
    min = ~ min(.x, na.rm = TRUE), 
    max = ~ max(.x, na.rm = TRUE)
)

starwars %>% summarise(across(where(is.numeric), min_max))

starwars %>% summarise(across(c(height, mass, birth_year), min_max))

starwars %>% summarise(across(where(is.numeric), min_max, .names = "{.fn}.{.col}"))
```


## Current column
If you need to, you can access the name of the "current" column inside by calling `cur_column()`. This can be useful if you want to perform some sort of context dependent transformation that's already encoded in a vector.  

```{r}
df <- tibble(
    x = 1:3, 
    y = 3:5, 
    z = 5:7
)

mult <- list(x = 1, y = 10, z = 100)

df %>% mutate(across(all_of(names(mult)), ~ .x * mult[[cur_column()]]))
```



## Gotchas
Be careful when combining numeric summaries with `where(is.numeric)`.  

```{r}
df <- data.frame(x = c(1, 2, 3), y = c(1, 4, 9))

df %>% 
    summarise(n = n(), 
              across(where(is.numeric), sd))
# the sd of constent is NA

df %>% 
    summarise(n = n(), 
              across(where(is.numeric) & !n, sd))

df %>% 
    summarise(across(where(is.numeric), sd), 
              n = n())

df %>% 
    summarise(
        tibble(n = n(), across(where(is.numeric), sd))
    )
```


## Other verbs
So far we've focused on the use of `across()` with `summarise()`, but it works with any other verbs that uses data masking.  


- Rescale all numeric variables to range 0-1.  

```{r}
rescale01 <- function(x){
    rng <- range(x, na.rm = TRUE)
    round((x - rng[[1]]) / (rng[[2]] - rng[[1]]), 3)
}

df <- tibble(
    x = 1:4, 
    y = rnorm(4)
)

df %>% mutate(across(where(is.numeric), rescale01))
```

For some verbs, like `group_by()`, `count()` and `distinct()`, you can omit the summary functions.  

- Find all distinct

```{r}
starwars %>% 
    distinct(across(contains("color")))
```


- Count all combinations of variables with a given pattern

```{r}
starwars %>% 
    count(across(contains("color")), sort = TRUE)
```

`across()` doesn't work with `select()` or `rename()` because they already use tidy select syntax; if you want to transform column names with a function, you can use `rename_with()`.  

## filter()
We cannot directly use `across()` in `filter()` because we need an extra step to combine the results. To that end, `filter()` has two special purpose companion functions.  

- `if_any()` keeps the rows where the predicate is true for at last one selected column.  

```{r}
starwars %>% 
    filter(if_any(everything(), ~ !is.na(.x)))
```


- `if_all()` keeps the rows where the predicate is true for all selected columns.  
```{r}
starwars %>% 
    filter(if_all(everything(), ~ !is.na(.x)))
```


- Find all rows where no variable has missing values.  
```{r}
starwars %>% 
    filter(across(everything(), ~!is.na(.x)))
```


## `_if`, `_at`, `_all`
Prior versions of dplyr allowed you to apply a function to multiple columns in a different way: using functions with `_if`, `_at`, and `_all()` suffixes. These functions solved a pressing need and are used by many people, but are now superseded. That means that they’ll stay around, but won’t receive any new features and will only get critical bug fixes.


## Why do we like `across()`?
Why did we decide to move away from these functions in favor of `across()`?

1. `across()` makes it possible to express useful summarises that were previously impossible. 

```{r}
df %>% 
    group_by(g1. g2) %>% 
    summarise(
        across(where(is.numeric), mean), 
        across(where(is.factor), nlevels), 
        n = n()
    )
```


2. `across()` reduces the number of functions that dplyr needs to provide. This makes dplyr easier for you to use (because there are fewer functions to remember) and easier for use to implement new verbs (since we only need to implement one function, not four).  

3. `across()` unifies `_if`, and `_at` semantics so that you can select position, name, and type, and you can now create compound selections that were previously impossible. For example, you can now transform all numeric columns whose name begain with "X": `across(where(is.numeric) & starts_with("X"))`.  

4. `across()` doesn't need to use `vars()`. The `_at` functions are only place in dplyr where you need to manually quote variable names, which makes them a little werrid and hence harder to remember.  


## Why did it so long to dicver `across()`?
It’s disappointing that we didn’t discover `across()` earlier, and instead worked through several false starts (first not realising that it was a common problem, then with the `_each()` functions, and most recently with the `_if()`/`_at()`/`_all()` functions). But across() couldn’t work without three recent discoveries.  

- You can have a column of a data frame that is itself a data frame. This is something provided by base R, but it's not only very well documented, and it took a while to see that it was useful, not just a theoretical curiosity. 

- We can use data frames to allow summary functions to return multiple columns.  

- We can use the absence of an outer name as a convention that you want to unpack a data frame column into individual columns.  








