---
stitle: "01 from base to dplyr"
author: "yincy"
date: "2023-01-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This vignette compares dplyr functions to their base R equivalents. This helps those familiar with base R understand better what dplyr does, and shows dplyr users how you might express the same ideas in base R code. We'll start with a rough overview of the major differences, then discuss the one table verbs in more detail, followed by the two table verbs.


# Overview

1.  The code dplyr verbs input and output data frames. This contrasts with base R functions which more frequently work with individual vectors.

2.  dplyr relies heavily on "non-standard evaluation" so that you don't need to use`$` to refer to columns in the "current" data frame. This behaviour is inspired by the base functions `subset()` and `transform()`.

3.  dplyr solutions tend to use a variety of single purpose verbs, while base R solutions typically tend to use [ in a variety of ways, depending on the task at hand.

4.  Multiple dplyr verbs are often strung together into a pipeline by `%>%`. In base R, you'll typically save intermediate results to a variable that you either discard, or repeatedly overwrite.

5.  All dplyr verbs handle "grouped" data frames so that the code to perform a computation per-group looks very similar to code that works on a whole data frame. In base R, per-group operations tend to have varied forms.


# One table verbs

The following table shows a condensed translation between dplyr verbs and their base R equivalents. The following sections describe each operation in more detail. You learn more about the dplyr verbs in their documentation and in For more vignette("one-table").

| **dplyr**                      | **base**                                                                                  |
|:-----------------------------------|:-----------------------------------|
| `arrange(df, x)`               | df[order(x), , drop = FALSE]                                                              |
| `distinct(df, x)`              | df[!duplicated(x), , drop = FALSE], unique()                                              |
| `filter(df, x)`                | df[which(x), , drop = FALSE], subset()                                                    |
| `mutate(df, z = x + y)`        | df$z <- df$x + df$y, transform()| |`pull(df, 1)`| df[[1]]| |`pull(df, x)`| df[["x]], df$x |
| `rename(df, y = x)`            | names(df)[names(df) == "x] \<- 'y'                                                        |
| `relocate(df, y)`              | df[union("y", names(df))]                                                                 |
| `select(df, x, y)`             | df[c("x", "y")], subset()                                                                 |
| `select(df, starts_with("x"))` | df[grepl(names(df), "\^x")]                                                               |
| `summarise(df, mean(x))`       | mean(df\$x), tapply(), aggregate(), by()                                                  |
| `slice(df, c(1, 2, 5))`        | df[c(1, 2, 5), , drop = FALSE]                                                            |



```{r}
library(dplyr)
mtcars <- as_tibble(mtcars)
iris <- as_tibble(iris)
```


## `arrange()`: arrange rows by variables
`dplyr::arrange()` orders the rows of a data frame by the values of one or more columns.  

```{r}
mtcars %>% arrange(cyl, disp)
```


The `desc()` helper allows you to order selected variables in decending order.  

```{r}
mtcars %>% arrange(desc(cyl), desc(disp))
```


```{r}
mtcars[order(mtcars$cyl, mtcars$disp), , drop = FALSE]

mtcars[order(mtcars$cyl, mtcars$disp, decreasing = TRUE), , drop = FALSE]
mtcars[order(-mtcars$cyl, -mtcars$disp), , drop = FALSE]
```


Note the use of `drop = FALSE`. If you forget this, and the input is a data frame with a single column, the output will be a vector, not a data frame.  



## `distinct()`: Select distinct/unique rows
`dplyr::distinct()` selects unique rows.  

```{r}
df <- tibble(
    x = sample(10, 100, replace = TRUE), 
    y = sample(10, 100, replace = TRUE)
)

df %>% distinct(x) # select one column
df %>% distinct(x, .keep_all = TRUE) # keep all variables
```

```{r}
unique(df["x"]) # select one column
df[!duplicated(df$x), , drop = F] # keep all variables
```

## `filter()`： return rows with matching conditions
`dplyr::filter()` selects rows where an expression is `TRUE`.  

**helper functions**

- `==`
- `>` 
- `>=`
- `<`
- `<=`

- `&`
- `|`
- `!`
- `xor()`
- `is.na()`
- `between()`
- `near()`


```{r}
starwars %>% filter(species == "Human")
starwars %>% filter(mass > 1000)
starwars %>% filter(hair_color == "none" & eye_color == "black")
```


The closest base equivalent (and the inspiration for `filter()`) is `subset()`:

```{r}
subset(starwars, species == "Human")
subset(starwars, mass > 1000)
subset(starwars, hair_color == "none" & eye_color == "black")

starwars[which(starwars$species == "Human"), , drop = FALSE]
starwars[which(starwars$mass > 1000), , drop = FALSE]
starwars[which(starwars$hair_color == "none" & starwars$eye_color == "black"), , drop = FALSE]
```


## `mutate()`: Create or transform variables
`dplyr::mutate()` creates new variables from existing variables:

```{r}
df %>% mutate(z = x + y, z2 = z ^2)

df %>% transmute(z = x + y, 
                 z2 = z^2)
# transmutate only keep the currently created variables
```

The closest base equivalent is `transform()`, but note that it cannot use freshly created variables

```{r}
transform(df, z = x + y, z2 = (x + y)^2)
```


When applied to a grouped data frame, `dplyr::mutate()` computes new variable once per group.  

```{r}
gf <- tibble(g = c(1, 1, 2, 2), 
             x = c(0.5, 1.5, 2.5, 3.5))

gf %>% 
    group_by(g) %>% 
    mutate(x_mean = mean(x), 
           x_rank = rank(x))
```


To replicate this in base R, you can use `ave()`.  
```{r}
transform(gf, 
          x_mean = ave(x, g, FUN = mean), 
          x_rank = ave(x, g, FUN = rank))
```


## `pull()`: Pull out a single variable
`dplyr::pull()` extracts a variable either by name  or by position.

```{r}
mtcars %>% pull(1)
mtcars %>% pull(cyl)
iris %>% pull(Sepal.Length, Species)  # pull a vector with name
```

```{r}
mtcars[[1]]
mtcars$cyl
```


## `relocate()`: Change column order
`dplyr::relocate()` makes it easy to move a set of columns to a new position (by default the front).  

```{r}
mtcars %>% relocate(gear, carb)
mtcars %>% relocate(mpg,cyl, .after = last_col())
```

```{r}
mtcars[union(c("gear", "carb"), names(mtcars))]
to_back <- c("gear", "cyl")
mtcars[c(setdiff(names(mtcars), to_back), to_back)]
```


## `rename()`: Rename variable by name
`dplyr::rename()` allows you to rename variables by name or position.

```{r}
iris %>% rename(speal_length = Sepal.Length, sepal_width = 2)
```


```{r}
iris2 <- iris
names(iris2)[2] <- "sepal_width"
iris2

names(iris2)[names(iris2) == "Sepal.Length"] <- "sepal_length"
iris2
```


## `rename_with()`: rename variables with a function
`dplyr::rename_with()` transform column names with a function.

```{r}
iris %>% rename_with(toupper)
```

```{r}
setNames(iris, toupper(names(iris)))
```


## `select()`: Select variables by name
`dplyr::select()` subsets columns by position, name, function of name, or other property.

**selection helpers**  
- `:`, for selecting a range of consecutive variables  
- `!`, for taking the complement of a set of variables, negative selection.  
- `&` and `|` for selecting the intersection or the union of two variables.  
- `c()`, for combining selections.  
- `everything()`, matches all variables.  
- `last_col()`, select last variable, possible with an offset.  
- `starts_with()`  
- `ends_with()`
- `contains()`  
- `matches()`
- `num_range()`, matches a numerical range like x01, x02, x03
- `all_of()`, matches variable names in a character vector. All names must be present, otherwise an out-of-bounds error is thrown.  
- `any_of()`, same as `all_of()`, except that no error is thrown for names that don't exist.  
- `where()`, applies a function to all variables and selects those for which the function return TRUE.  

```{r}
iris %>% select(1:3)
iris %>% select(Species, Sepal.Length)
iris %>% select(starts_with("Petal"))
iris %>% select(where(is.factor))
```

```{r}
iris[1:3] # single argument selects columns, never drops
iris[1:3, , drop = F]
iris[c("Sepal.Length", "Species")]
iris[grep("^Petal", names(iris))]
Filter(is.factor, iris)
```


## `summarise()`: Reduce multiple values down to a single value
`dplyr::summarise()` computes one or more summarises for each group.  

```{r}
mtcars %>% 
    group_by(cyl) %>% 
    summarise(mean = mean(disp), 
              n = n())
```

```{r}
mtcars_by <- by(mtcars, INDICES = mtcars$cyl, FUN = function(df){
    with(df, data.frame(cyl = cyl[[1]], mean = mean(disp), n = nrow(df)))
})
do.call(rbind, mtcars_by)
```

```{r}
agg <- aggregate(disp ~ cyl, data = mtcars, FUN = function(x){c(mean = mean(x), n = length(x))})
str(agg)
```


## `slice()`: CHoose rows by position
`slice()` selects rows with their location.  
- slice  
- slice_head  
- slice_tail
- slice_max
- slice_min
- slice_sample

```{r}
slice(mtcars, 25:n())
```

```{r}
mtcars[25:nrow(mtcars), , drop = F]
```


# Two-table verbs
When we want to merge two data frames, x and y, we have a variety of different ways to bring them together. Various base R `merge()` calls are replaced by a variety of dplyr `join()` functions.  

|**dplyr**|**base**|
|:--|:--|
|`inner_join(df1, df2)`| merge(df1, df2)|
|`left_join(df1, df2)`| merge(df1, df2, all.x = TRUE)|
|`right_join(df1, df2)`| merge(df1, df2, all.y = TRUE)|
|`full_join(df1, df2)`| merge(df1, df2, all = TRUE)|
|`semi_join(df1, df2)`| df1[df1$x %in% df2$x, , drop = FALSE]|
|`anti_join(df1, df2)`| df1[!df1$x %in% df2$x, , drop = F]


## Mutating joins
dplyr’s `inner_join()`, `left_join()`, `right_join()`, and `full_join()` add new columns from y to x, matching rows based on a set of “keys”, and differ only in how missing matches are handled. They are equivalent to calls to `merge()` with various settings of the `all`, `all.x`, and `all.y` arguments. The main difference is the order of the rows:

- dplyr preserves the order of the x data frame.
- `merge()` sorts the key columns.


## Filtering joins
dplyr's `semi_join()` and `anti_join()` affect only the rows, not the columns.  
filter x based on y.  

```{r, message=FALSE}
band_members %>% semi_join(band_instruments)
band_members %>% anti_join(band_instruments)
```


```{r}
band_members[band_members$name %in% band_instruments$name, , drop = F]
band_members[!band_members$name %in% band_instruments$name, , drop = F]
```




