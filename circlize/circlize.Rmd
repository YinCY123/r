---
title: "circlize"
author: "yincy"
date: "4/27/2020"
output: html_document:
  toc: true
  toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE}
library(circlize)
```

# Chapter 1 Introduction  
Circular layout is very useful to represent complicated information. First, it elegantly represents information with long axes or a large amount of categories; second, it intuitively shows data with multiple tracks focusing on the same object; third, it easily demonstrates relations between elements. It provides an efficient way to arrange information on the circle and it is beautiful.  

Circos is a pioneer tool widely used for circular layout representations implemented in Perl. It greatly enhances the visualization of scientific results (especially in Genomics field). Thus, plots with circular layout are normally named as “circos plot”. Here the **circlize** package aims to implement Circos in R. One important advantage for the implementation in R is that R is an ideal environment which provides seamless connection between data analysis and data visualization. circlize is not a front-end wrapper to generate configuration files for Circos, while completely coded in R style by using R’s elegant statistical and graphic engine. We aim to keep the flexibility and configurability of Circos, but also make the package more straightforward to use and enhance it to support more types of graphics.  

In this book, chapters in Part I give detailed overviews of the general circlize functionalities. Part II introduces functions specifically designed for visualizing genomic datasets. Part III gives comprehensive guilds on visualizing relationships by Chord diagram.  

## Principle of design  
**A circular layout is composed of sectors and tracks**. For data in different categories, they are allocated into different sectors and for multiple measurements of the same category, they are represented as stacked tracks from outside of the circle to the inside. **The intersection of a sector and a track is called a cell (or a grid, a panel), which is the basic unit in a circular layout**. It is an imaginary plotting region for data points in a certain category.  

Since most of the figures are composed of simple graphics, such as points, lines, polygon, circlize implements low-level graphic functions for adding graphics in the circular plotting regions, so that more complicated graphics can be easily generated by different combinations of low-level graphic functions. This principle ensures the generality that types of high-level graphics are not restricted by the software itself and high-level packages focusing on specific interests can be built on it.  

Currently there are following low-level graphic functions that can be used for adding graphics. The usage is very similar to the functions without `circos`. prefix from the base graphic engine, except there are some enhancement specifically designed for circular visualization.  

+ `circos.points()`: adds points in a cell.  
+ `circos.lines()`: adds lines in a cell.  
+ `circos.segments()`: adds segments in a cell.  
+ `circos.rect()`: adds rectangles in a cell.  
+ `circos.polygon()`: adds polygons in a cell.  
+ `circos.text`: adds text in a cell.  
+ `circos.axis()` ands `circos.yaxis()`: add axis in a cell.  

Following functions arrange the circular layout  

+ `circos.initialize()`: allocates sectors on the circle.  
+ `circos.track()`: create plotting regions for cells in one single track.  
+ `circos.update()`: updates an existed cell.  
+ `circos.par()`: graphic parameters.  
+ `circos.clear()`: resets graphic parameters and internal variables.  

Thus, theoretically, you are able to draw most kinds of circular figures by the above functionalities. 

## A quick glance  
```{r}
set.seed(999)

n = 1000
df <- data.frame(
    factors = sample(letters[1:8], n , replace = T), 
    x = rnorm(n), 
    y = runif(n)
)
```

First we initialize the circular layout. The circle is split into sectors based on the data range on x-axes in each category. In following code, df$x is split by df$factors and the width of sectors are automatically calculated based on data ranges in each category. Be default, sectors are positioned started from  θ = 0 (in the polar coordinate system) and go along the circle clock-wisely. You may not see anything after running following code because no track has been added yet.  

We set a global parameter track.height to 0.1 by the option function `circis.par()` so that all tracks which will be added have a default height of 0.1. The circle used by circlize always has a radius of 1, so a height of 0.1 means 10% of the circle radius.  

**Note that the allocation of sectors only needs values on x direction (or on the circular direction), the values on y direction (radical direction) will be used in the step of creating tracks**.  

After the circular layout is initialized, graphics can be added to the plot in a track-by-track manner. Before drawing anything, we need to know that all tracks should be first created by `circos.trackPlotRegion()` or, for short, `circos.track()`, then the low-level functions can be added afterwards. Just think in the base R graphic engine, you need first call `plot()` then you can use functions such as `points()` and `lines()` to add graphics. Since x ranges for cells in the track have already been defined in the initialization step, here we only need to specify the y ranges for each cell. The y ranges can be specified by y argument as a numeric vector (so that y ranges will be automatically extracted and calculated in each cell) or ylim argument as a vector of length two. In principle, y ranges should be same for all cells in a same track.  
```{r, message=FALSE, warning=FALSE}
library(circlize)

circos.par("track.height" = 0.1)
circos.initialize(factors = df$factors, x = df$x)

# first track 
circos.track(factors = df$factors, y = df$y, 
             panel.fun = function(x, y){
                 circos.text(x = CELL_META$xcenter, 
                             y = CELL_META$cell.ylim[2] + uy(5, "mm"), 
                             labels = CELL_META$sector.index)
                 circos.axis(labels.cex = 0.6)
             })

col <- rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$factors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(x = -1, y = 0.5, label = "text", sector.index = "a", track.index = 1)

# second track
bgcol <- rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(factors = df$factors, x = df$x, bin.size = 0.2, bg.col = bgcol, col = NA)

# third track 
circos.track(factors = df$factors, x = df$x, y = df$y, 
             panel.fun = function(x, y){
               ind = sample(length(x), 10)
               x2 = x[ind]
               y2 = y[ind]
               od = order(x2)
               circos.lines(x2[od], y2[od])
             })

# update cell 'd' in second track 
circos.update(sector.index = "d", track.index = 2, bg.col = "#FF8080", bg.border = "black")
circos.points(x = -2.2, y = rep(0.5, 5), col = "white")
circos.text(x = CELL_META$xcenter, y = CELL_META$ycenter, labels = 'updated', col = "white")

# fourth track, heatmap 
circos.track(ylim = c(0, 1), panel.fun = function(x, y){
  xlim = CELL_META$xlim
  ylim = CELL_META$ylim
  breaks = seq(xlim[1], xlim[2], by = 0.1)
  n_breaks = length(breaks)
  circos.rect(xleft = breaks[-n_breaks], ybottom = rep(ylim[1], n_breaks - 1), 
              breaks[-1], rep(ylim[2], n_breaks -1), 
              col = rand_color(n_breaks), border = NA)
})

# fith track, links  
circos.link(sector.index1 = "a", point1 = 0, sector.index2 = "b", point2 = 0, h = 0.4)
circos.link(sector.index1 = "c", point1 = c(-0.5, 0.5), sector.index2 = "d", point2 = c(-0.5, 0.5), col = "red", 
            border = "blue", h = 0.2)
circos.link(sector.index1 = "e", point1 = 0, sector.index2 ="g", point2 = c(-1, 1), col = "green", border = "black", lwd = 2, lty  =2)

# reset the graphic parameters and internal variables, so that it will not mess up your next plot 
circos.clear()
```


# Chapter 2 Circular layout  
## Coordinate transformation  
o map graphics onto the circle, there exist transformations from several coordinate systems. First, there are data coordinate systems in which ranges for x-axes and y-axes are the ranges of original data. Second, there is a polar coordinate system in which these coordinates are mapped onto a circle. Finally, there is a canvas coordinate system in which graphics are really drawn on the graphical device.  

Each cell has its own data coordinate and they are independent. `circlize` first transforms coordinates from data coordinate system to polar coordinate system and finally transforms into canvas coordinate system.   

For users, they only need to imagine that each cell is a normal rectangular plotting region (data coordinate) in which x-lim and y-lim are ranges of data in that cell. `circlize` knows which cell you are in and does all the transformations automatically.  

The final canvas coordinate is in fact an ordinary coordinate in the base R graphic system with x range in (-1, 1) and y range in (-1, 1) by default. It should be noted that **the circular plot is always drawn inside the circle which has radius of 1 (which means it is always a unit circle), and from outside to inside**.   

## Rules for making the circular plot  
The rule for making the circular plot is rather simple. It follows the sequence of `initialize layout -> create track -> add graphics -> create track -> add graphics - ... -> clear`. Graphics can be added at any time as long as the tracks are created.  

1. Initialize the layout using `circos.initialize()`. Since circular layout in fact visualizs data which is in categories, there must be at least a categorial variable. Ranges of x values on each category can be specified as a vector or the range itself.  

2. Create plotting regions for the new track and add graphics. The new track is created just inside the previously created one. Only after the creation of the track can you add other graphics on it. There are three ways to add graphics in cells.  

+ After the creation of the track, use low-level graphic function like `circos.points()`, `circos.lines()`, … to add graphics cell by cell. It always involves a for loop and you need to subset the data by the categorical variable manually.  

+ Use `circos.trackPoints()`, `circos.trackLines()`, … to add simple graphics through all cells simultaneously.  

+ Use `panel.fun` argument in `circos.track()` to add graphics immediately after the creation of a certain cell. `panel.fun` needs two arguments `x` and `y` which are `x` values and `y` values that are in the current cell. This subset operation is applied automatically. This is the most recommended way. Section 2.7 gives detailed explanation of using panel.fun argument.  

+ Repeat step 2 to add more tracks on the circle unless it reaches the center of the circle.  

+ Call circos.clear() to clean up.  

As mentioned above, there are three ways to add graphics on a track.  

1. Create plotting regions for the whole track first and then add graphics by specifying `sector.index`. In the following pseudo code, `x1`, `y1` are data points in a given cell, which means you need to do data subsetting manually.  

In following code, circos.points() and circos.lines() are used separatedly from circos.track(), thus, the index for the sector needs to be explicitly specified by sector.index argument.  

There is also a `track.index` argument for both functions, however, the default value is the “current” track index and as the two functions are used just after `circos.track()`, the “current” track index is what the two functions expect and it can be ommited when calling the two functions.  

```
circos.initialize(factors = factors, x = xlim)
circos.track(factors, ylim)
for(sector.index in all.sector.index){
  circos.points(x1, y1, sector.index)
  circos.lines(x2, y2, sector.index)
}
```

2. Add graphics in a batch mode. In following code, `circos.trackPoints()` and `circos.trackLines()` need a categorical variable, a vector of x values and a vector of y values. X and y values will be split by the categorical variable and sent to corresponding cell to add the graphics. Internally, this is done by using `circos.points()` or `circos.lines()` in a for loop. This way to add graphics would be convenient if users only want to add a specific type of simple graphics (e.g. only points) to the track, but it is not recommended for making complex graphics.  

`circos.trackPoints()` and `circos.trackLines()` need a `track.index` to specify which track to add the graphics. Similarly, since these two are called just after `circos.track()`, the graphics are added in the newly created track right away.  
```
circos.initialize(factors, xlim)
circos.track(factors, ylim)
circos.trackPoints(factors, x, y)
circos.trackLines(factors, x, y)
```

3. Use a panel function to add self-defined graphics as soon as the cell has been created. This is the way recommended and you can find most of the code in this book uses `panel.fun`. `circos.track()` creates cells one by one and after the creation of a cell, and `panel.fun` is executed on this cell immediately. In this case, the “current” sector and “current” track are marked to this cell that you can directly use low-level functions without specifying sector index and track index.  

If you look at following code, you will find the code inside `panel.fun` is as natural as using `points()` or `lines()` in the normal R graphic system. This is a way to help you think a cell is an “imaginary rectangular plotting region”.  

```
circos.initialize(factors, xlim)
circos.track(factors, all_x, all_y, ylim, 
             panel.fun = function(x, y){
               circos.points(x, y)
               circos.lines(x, y)
             })
```

There are several internal variables keeping tracing of the current sector and track when applying `circos.track()` and `circos.update()`. Thus, although functions like `circos.points()`, `circos.lines()` need to specify the index of sector and track, they will take the current one by default. As a result, if you draw points, lines, text et al just after the creation of the track or cell, you do not need to set the sector index and the track index explicitly and it will be added in the most recently created or updated cell.  


## Sectors and tracks  
A circular layout is composed of sectors and tracks. As illustrated in Figure 2.3, the red circle is one track and the blue represents one sector. The intersection of a sector and a track is called a cell which can be thought as an imaginary plotting region for data points. In this section, we introduce how to set data ranges on x and y directions in cells.  
```{r, fig.align='center'}
knitr::include_graphics(path = "/home/yincy/git/R-codes/circlize/figures/Sectors-and-tracks.png")
```

Sectors are first allocated on the circle by `circos.initialize()`. There must be a categorical variable (say `factors`) that on the circle, each sector corresponds to one category. The width of sectors (measured by degree) are proportional to the data range in sectors on `x` direction (or the circular direction). The data range can be specified as a numeric vector `x` which has same length as `factors`, then `x` is split by `factors` and data ranges are calculated for each sector internally.   

Data ranges can also be specified directly by `xlim` argument. The valid value for `xilm` is a two-column matrix with same number of rows as number of sectors that each row in `xlim` corresponds to one sector. If `xlim` has row names which already cover sector names, row order of `xlim` is automatically adjusted. If `xlim` is a vector of length two, all sectors have the same `x` range.  
```
circos.initialize(factors, x = x)
circos.initialize(factors, xlim = xlim)
```

After the initialization of the layout, you may not see anything drawn or only an empty graphical device is opened. That is because no track has been created yet, however, the layout has already been recorded internally.  

**In the initialization step, not only the width of each sector is assigned, but also the order of sectors on the circle is determined**. **Order of the sectors are determined by the order of levels of the input factor**. If the value for `factors` is not a factor, the order of sectors is `unique(factors)`. Thus, if you want to change the order of sectors, you can just change of the level of `factors` variable. The following code generates plots with different sector orders.  
```
fa <- c('d', 'f', 'e', 'c', 'g', 'b', 'a')
f1 <- factor(fa)
circos.initialize(factors = f1, xlim = c(0, 1))
f2 <- factor(fa, levels = fa)
circos.initialize(factors = f2, xlim = c(0, 1))
```
```{r, fig.align='center'}
knitr::include_graphics("/home/yincy/git/R-codes/circlize/figures/sector-orders.png")
```

**In different tracks, cells in the same sector share the same data range on x-axes**. Then, **for each track, we only need to specify the data range on y direction (or the radical direction) for cells**. Similar as `circos.initialize()`, `circos.track()` also receives either `y` or `ylim` argument to specify the range of y-values. Since all cells in a same track shares a same `y` range, `ylim` is just a vector of length two if it is specified.  

`x` can also be specified in `circos.track()`, but it is only used to send to panel.fun. In Section 2.7, we will introduce how `x` and `y` are sent to each cell and how the graphics are added.  

```
circos.track(factors, y = y)
circos.track(factors, ylim = c(0, 1))
circos.track(factors, x = x, y = y)
```

In the track creation step, since all sectors have already been allocated in the circle, if `factors` argument is not set, `circos.track()` would create plotting regions for all available sectors. Also, levels of `factors` do not need to be specified explicitly because the order of sectors has already be determined in the initialization step. If users only create cells for a subset of sectors in the track (not all sectors), in fact, cells in remaining unspecified sectors are created as well, but with no borders (pretending they are not created).  

```
# assume 'factors' only covers a subset of sector  
# You will only see cells that are covered in 'factors' have borders  

circos.track(factors, y = y)

# You will see all cells have borders
circos.track(ylim = ranges(y))
```

Cells are basic units in the circular plot and are independent from each other. After the creation of cells, they have self-contained meta values of x-lim and y-lim (data range measured in data coordinate). So if you are adding graphics in one cell, you do not need to consider things outside the cell and also you do not need to consider you are in the circle. Just pretending it is normal rectangle region with its own coordinate.  

```{r, fig.align='center'}
knitr::include_graphics("/home/yincy/git/R-codes/circlize/figures/Sector-directions.png")
```

## Graphic parameters  
Some basic parameters for the circular layout can be set by `circos.par()`. These parameters are listed as follows. Note **some parameters can only be modified before the initialization of the circular layout**.  

+ `start.degree`: The starting degree where the first sector is put. Note this degree is measured in the standard polar coordinate system which means it is always reverse clockwise. E.g. if it is set to 90, sector start from the top of the circle.  

+ `gap.degree`: Gap between two neighbor sectors. It can be a single value which means all gaps share same degree, or a vector which has same number as sectors. **Note the first gap is after the first sector**.  

+ `gap.after`: Same as gap.degree, but more understandable. Modifying values of gap.after will also modify gap.degree and vice versa.  

+ `track.margin`: Like margin in Cascading Style Sheets (CSS), it is the blank area out of the plotting region, also outside of the borders. Since left and right margin are controlled by gap.after, only bottom and top margin need to be set. The value for `track.margin` is the percentage to the radius of the unit circle. The value can also be set by `convert_height()` or the short version `uh()` function with absolute units.  

+ `cell.padding`: Padding of the cell. Like padding in Cascading Style Sheets (CSS), it is the blank area around the plotting regions, but within the borders. The parameter has four values, which control the bottom, left, top and right padding respectively. The first and the third padding values are the percentages to the radius of the unit circle, and the second and fourth values are the degrees. The first and the third value can be set by uh() with absolute units.  

+ `unit.circle.segments`: Since curves are simulated by a series of straight lines, this parameter controls the amount of segments to represent a curve. The minimal length of the line segment is the length of the unit circle (2π) divided by `unit.circle.segments`. More segments means better approximation for the curves, while generate larger file size if figures are in PDF format.

+ `track.height`: The default height of tracks. It is the percentage to the radius of the unit circle. The height includes the top and bottom cell paddings but not the margins. The value can be set by `uh()` with absolute units.  

+ `points.overflow.warning`: Since each cell is in fact not a real plotting region but only an ordinary rectangle (or more precisely, a circular rectangle), it does not remove points that are plotted outside of the region. So if some points (or lines, text) are out of the plotting region, by default, the package would continue drawing the points but with warning messages. However, in some circumstances, drawing something out of the plotting region is useful, such as adding some text annotations (like the first track in Figure 1.2). Set this value to FALSE to turn off the warnings.  

+ `canvas.xlim`: The ranges in the canvas coordinate in x direction. **circlize** is forced to put everything inside the unit circle, so `canvas.xlim` and `canvas.ylim` is `c(-1, 1)` by default. However, you can set it to a more broad interval if you want to leave more spaces out of the circle. By choosing proper canvas.xlim and canvas.ylim, actually you can customize the circle. E.g. setting `canvas.xlim` to `c(0, 1)` and `canvas.ylim` to `c(0, 1)` would only draw 1/4 of the circle.  

+ clock.wise: The order for drawing sectors. Default is TRUE which means clockwise. **Note that inside each cell, the direction of x-axis is always clockwise and direction of y-axis is always from inside to outside in the circle**.   

```{r, fig.align='center'}
knitr::include_graphics("figures/regions-in-a-cell.PNG")
```

Default values for graphic parameters are listed in following table.  

**Parameters**--------------|-**Values**------------------
`start.degree`              | 0
`gap.degree`/`gap.after`    | 1
`track.margin`              | c(0.01, 0.01)
`cell.padding`              | c(0.02, 1.00, 0.02, 1.00)
`unit.circle.segments`      | 500
`track.heigth`              | 0.2 
`points.overflow.warning`   | TRUE
`canvas.xlim`               | c(-1, 1)
`canvas.ylim`               | c(-1, 1)
`clock.wise`                | TRUE  

Parameters related to the allocation of sectors cannot be changed after the initialization of the circular layout. Thus, `start.degree`, `gap.degree`/`gap.after`, `canvas.xlim`, `canvas.ylim` and `clock.wise` can only be modified before `circos.initialize()`. The second and the fourth values of `cell.padding` (left and right paddings) can not be modified neither (or will be ignored).  

Similar reason, since some of the parameters are defined before the initialization of the circular layout, after making each plot, you need to call `circos.clear()` to manually reset all the parameters.  


## Create plotting regions  
As described above, only after creating the plotting region can you add low- level graphics on it. The minimal set of arguments for `circos.track()` is to set either `y` or `ylim` which assigns range of y values for this track. `circos.track()` creates tracks for all sectors although in some case only parts of them are visible.  

If `factors` is not specified, all cells in the track will be created with the same settings.If `factors`, `x` and `y` are set, they need to be vectors with the same length. **Proper values of `x` and `y` that correspond to current cell will be passed to `panel.fun` by subsetting `factors` internally**.  

Graphic arguments such as `bg.border` and `bg.col` can either be a scalar or a vector. If it is a vector, the length must be equal to the number of sectors and the order corresponds to the order of sectors. Thus, you can create plot regions with different styles of borders and background colors.  

If you are confused with the factors orders, you can also customize the borders and background colors inside `panel.fun`. `get.cell.meta.data("cell.xlim")` and `get.cell.meta.data("cell.ylim")` give you dimensions of the plotting region and you can customize plot regions directly by e.g. `circos.rect(col = "#FF000040", border = 1)`.  

`circos.track()` provides track.margin and cell.padding arguments that they only control track margins and cell paddings for the current track. Of course the second and fourth value in cell.padding are ignored.  


## Update plotting regions  
circos.track() creates new tracks, however, if track.index argument is set to a track which already exists, `circos.track()` actually `re-creates` this track. In this case, coordinates on y directions can be re-defined, but settings related to the positions of the track such as the height of the track can not be modified.  

```{r, eval=FALSE}
circos.track(factors, ylim = c(0,1), track.index = 1, ...)
```

For a single cell, `circos.update()` can be used to erase all graphics that have been already added in the cell. However, the data coordinate in the cell keeps unchanged.  

```{r, eval=FALSE}
circos.update(sector.index, track.index)
circos.points(x, y, sector.index, track.index)
```


## `panel.fun` argument  
```{r, eval=FALSE}
factors <- c("a", "a", "a", "b", "b")
x = 1:5
y = 5:1

circos.track(factors = rep(factors, 20), 
             x = x, 
             y = y, 
             panel.fun = function(x, y){
               circos.points(x, y)
             })
```

In `panel.fun`, one thing important is that if you use any low-level graphic functions, you don’t need to specify `sector.index` and `track.index` explicitly. Remember that when applying `circos.track()`, cells in the track are created one after one. When a cell is created, **circlize** would set the sector index and track index of the cell as the ‘current’ index. When the cell is created, panel.fun is executed immediately. Without specifying `sector.index` and `track.index`, the ‘current’ ones are used and that’s exactly what you need.  

The advantage of `panel.fun` is that it makes you feel you are using graphic functions in the base graphic engine (You can see it is almost the same of using `circos.points(x, y)` and `points(x, y)`). It will be much easier for users to understand and customize new graphics.  

Inside `panel.fun`, information of the ‘current’ cell can be obtained through `get.cell.meta.data()`. Also this function takes the ‘current’ sector and ‘current’ track by default.  
```{r, eval=FALSE}
get.cell.meta.data(name)
get.cell.meta.data(name, sector.index, track.index)
```

Information that can be extracted by get.cell.meta.data() are:  

+ `sector.index`: The name for the sector.  
+ `sector.numeric.index`: Numeric index for the sector.  
+ `track.index`: Numeric index for the track.  
+ `xlim`: Minimal and maximal values on the x-axis.  
+ `ylim`: Minimal and maximal values on the y-axis.  
+ `xcenter`: mean of xlim.  
+ `ycenter`: mean of ylim.  
+ `xrange`: defined as xlim[2] - xlim[1].  
+ `yrange`: defined as ylim[2] - ylim[1].  
+ `cell.xlim`: Minimal and maximal values on the x-axis extended by cell paddings.  
+ `cell.ylim`: Minimal and maximal values on the y-axis extended by cell paddings.  
+ `xplot`: Degree of right and left borders in the plotting region. The first element corresponds to the start point of values on x-axis and the second element corresponds to the end point of values on x-axis Since x-axis in data coordinate in cells are always clockwise, xplot[1] is larger than xplot[2].  
+ `yplot`: Radius of bottom and top radius in the plotting region.  
+ `cell.start.degree`: Same as xplot[1].  
+ `cell.end.degree`: Same as xplot[2].  
+ `cell.bottom.radius`: Same as yplot[1].  
+ `cell.top.radius`: Same as yplot[2]. 
+ `track.margin`: Margins of the cell.  
+ `cell.padding`: Paddings of the cell.  

Following example code uses `get.cell.meta.data()` to add sector index in the center of each cell.  

```{r, eval=FALSE}
circos.track(ylim = ylim, panel.fun = function(x, y){
  sector.index = get.cell.meta.data(name = "sector.index")
  xcenter = get.cell.meta.data(name = "xcenter")
  ycenter = get.cell.meta.data(name = "ycenter")
  circos.text(xcenter, ycenter, sector.index = sector.index)
})
```

`get.cell.meta.data()` can also be used outside `panel.fun`, but you need to explictly specify `sector.index` and `track.index` arguments unless the current index is what you want.   

There is a companion variable `CELL_META` which is identical to `get.cell.meta.data()`to get cell meta information, but easier and shorter to write. Actually, the value of `CELL_META` itself is meaningless, but e.g. `CELL_META$sector.index` is automatically redirected to get.cell.meta.data("`sector.index`"). Following code rewrites above example code with `CELL_META`.  

```{r, eval=FALSE}
circos.track(ylim = yim, panel.fun = function(x, y){
  circos.text(x = CELL_META$xcenter, y = CELL_META$ycenter, 
              labels = CELL_META$sector.index)
})
```

Please note `CELL_META` only extracts information for the “current” cell, thus, it is recommended to use only in `panel.fun`.  

Nevertheless, if you have several lines of code which need to be executed out of `panel.fun`, you can flag the specified cell as the 'current' cell by `set.current.cell()`, which can save you from typing too many `sector.index = ..., track.index = ...,`. E.g. following code  

```{r}
circos.text(get.cell.meta.data(name = "xcenter", sector.index, track.index), 
            get.cell.meta.data(name = "ycenter", sector.index, track.index), 
            get.cell.meta.data(name = "sector.index", sector.index, track.index), 
            sector.index, track.index)
```

can be simplified to  
```{r, eval=FALSE}
set.current.cell(sector.index, track.index)
circos.text(x = get.cell.meta.data(name = "xcenter"), 
            y = get.cell.meta.data(name = "ycenter"), 
            labels = get.cell.meta.data(name = "sector.index"))

# or more simple 
circos.text(x = CELL_META$xcenter, 
            y = CELL_META$ycenter, 
            labels = CELL_META$sector.index)
```


## Other utilities  
**circlize** transform data points in several coordinate systems and it is basically done by the core function `circlize()`. The function transforms from data coordinate (coordinate in the cell) to the polar coordinate and its companion `reverse.circlize()` transforms from polar coordinate to a specified data coordinate. The default transformation is applied in the `current` cell.  

```{r}
factors = c("a", "b")
circos.initialize(factors, xlim = c(0, 1))
circos.track(ylim = c(0, 1))
```

```{r}
# x = 0.5, y = 0.5 in sector a and track 1
circlize(x = 0.5, y = 0.5, sector.index = "a", track.index = 1)
```


```{r}
# theta = 90, rou = 0.9 in the polar coordinate  
reverse.circlize(x = 90, y = 0.9, sector.index = "a", track.index = 1)
```

`circlize()` and `reverse.circlize()` can be used to connect two circular plots if they are drawn on a same page. This provides a way to build more complex plots. Basically, the two circular plots share a same polar coordiante, then, the manipulation of `circlize->reverse.circlize->circlize` can transform coordinate for data points from the first circular plot to the second.  

The transformation between polar coordinate and canvas coordinate is simple. **circlize** has a `circlize:::polar2Cartesian()` function but this function is not exported.  

Following example (Figure 2.7) adds raster image to the circular plot. The raster image is added by `rasterImage()` which is applied in the canvas coordinate. Note how we change coordinate from data coordinate to canvas coordinate by using `circlize()` and `circlize:::polar2Cartesian()`.  


### The convert functions  
For the functions in circlize package, they needs arguments which are lengths measured either in the canvas coordinate or in the data coordinate. E.g. track.height argument in circos.track() corresponds to percent of radius of the unit circle. circlize package is built in the R base graphic system which is not straightforward to define a length with absolute units (e.g. a line of length 2 cm). To solve this problem, circlize provides three functions which convert absolute units to the canvas coordinate or the data coordinate accordingly.  

`convert_length()` converts absolute units to the canvas coordinate. Since the aspect ratio for canvas coordinate is always set to 1, it doesn’t matter whether to convert units in the x direction or in the y direction. The usage of `convert_length()` is straightforward, supported units are `mm`, `cm` and `inches`. If users want to convert a string height or width to the canvas coordinate, directly use `strheight()` or `strwidth()` functions.  

```{r}
convert_length(x = 2, unit = "mm")
```

Since `convert_length()` is mostly used to define heights on the radical direction, e.g. track height or height of track margins, the function has another name `convert_height()`, or the short name `uh()` (stands for unit height).  

`convert_x()` and `convert_y()`, or the short version `ux()` and `uy()` (unit x and unit y), convert absolute units to the data coordinate.  

By default, the conversion is applied in the “current” cell, but it can still be used in other cells by specifying `sector.index` and `track.index` arguments. Since the width of the cell is not identical from the top to the bottom in the cell, for `convert_x()` or `ux()` function, the position on y direction where the convert is applied needs to be specified. By default it is at the middle point on y-axis.  

```{r}
fa = letters[1:10]
circos.par(cell.padding = c(0, 0, 0, 0), track.margin = c(0, 0))
circos.initialize(fa, xlim = cbind(rep(0, 10), runif(10, 0.5, 1.5)))
circos.track(ylim = c(0, 1), track.height = uh(2, "mm"),
    panel.fun = function(x, y) {
        circos.lines(c(0, 0 + ux(5, "mm")), c(0.5, 0.5), col = "blue")
    })

circos.track(ylim = c(0, 1), track.height = uh(1, "cm"),
    track.margin = c(0, uh(2, "mm")),
    panel.fun = function(x, y) {
        xcenter = get.cell.meta.data("xcenter")
        circos.lines(c(xcenter, xcenter), c(0, uy(1, "cm")), col = "red")
    })

circos.track(ylim = c(0, 1), track.height = uh(1, "inches"),
    track.margin = c(0, uh(2, "mm")),
    panel.fun = function(x, y) {
        line_length_on_x = ux(1*sqrt(2)/2, "cm")
        line_length_on_y = uy(1*sqrt(2)/2, "cm")
        circos.lines(c(0, line_length_on_x), c(0, line_length_on_y), col = "orange")
    })

circos.clear()
```



### `circos.info()` and `circos.clear()`  
You can ge basic information of your current circular plot by `circos.info()`. The function can be called at any time.  
```{r}
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(1, 2))
circos.info()
```

```{r}
circos.track(ylim = c(0, 1))
circos.info(sector.index = "a", track.index = 1)
```

```{r}
circos.clear()
```

It can also add labels to all cells by `circos.info(plot = TRUE`  


# Chapter 3 Graphics 
All low-level functions accept sector.index and track.index arguments which indicate which cell the graphics are added in. By default the graphics are added in the “current” sector and “current” track, so it is recommended to use them directly inside panel.fun function.  

```{r, eval=FALSE}
circos.track(..., panel.fun = function(x, y){
  circos.points(x, y)
})

circos.points(x, y, sector.index, track.index)
```


## Points  
`circos.points()` is similar as `points()` function  
```{r}
circos.points(x, y)
circos.points(x, y, sector.index, track.index)
circos.points(x, y, pch, col, cex)
```

There is a companion function circos.trackPoints() which adds points to all sectors in a same track simultaneously.  

The input of `circos.trackPoints()` must contain a vector of categorical factors, a vector of x values and a vector of y values. X values and y values are split by the categorical variable and corresponding subset of x and y values are internally sent to `circos.points()`.  

`circos.trackPoints()` adds points to the “current” track by default which is the most recently created track. Other tracks can also be selected by explictly setting `track.index` argument.  

```{r, eval=FALSE}
circos.track(...)
circos.trackPoints(fa, x, y)
```

`circos.trackPoints()` is simply implemented by `circos.points()` with a for loop. However, it is more recommended to directly use `circos.points()` and `panel.fun` which provides great more flexibility.  
```{r, eval=FALSE}
circos.track(fa, x, y, panel.fun = function(x, y){
  circos.points(x, y)
})
```

Other low-level functions also have their companion `circos.track*()` function. The usage is same as `circos.trackPoints()` and they will not be further discussed in following sections.  


## Lines  
Adding lines by · is similar as `lines()` function. One additional feature is that the areas under or above the lines can be filled by specifing `area` argument to TRUE. Position of the baseline can be set to a pre-defined string of `bottom` or `top`, or a numeric value which is the position on y-axis. When `area` is set to TRUE, `col` controls the filled color and `border` controls the color for the borders.  

`baseline` argument is also workable when `lty` is set to "h". Note when `lty` is set to "h", graphic parameters such as `col` can be set as a vector with same length as `x`.  

```{r, fig.align='center'}
knitr::include_graphics("figures/Line-styles-and-areas-supported.PNG")
```

```{r, eval=FALSE}
circos.lines(x, y)
circos.lines(x, y, sector.index, track.index)
circos.lines(x, y, col, lwd, lty, type, straight)
circos.lines(x, y, col, area, baseline, border)
```


## Segments  
Line segments can be added by `circos.segments()` function. The usage is simiar as `segments()`. Radical segments can be added by setting `straight` to `TRUE`.  
```{r, eval=FALSE}
circos.segments(x0, y0, x1, y1)
circos.segments(x0, y0, x1, y1, straight)
```


## Text  
Adding text by `circos.text()` is similar as `text()` function. Text is added on the plot for human reading, thus, when putting the text on the circle, the facing of text is very important. `circos.text()` supports seven facing options which are `inside`, `outside`, `clockwise`, `reverse.clockwise`, `downward`, `bending.inside` and `bending.outside`. Please note for `bending.inside` and `bending.outside`, currently, single line text is only supported. If you want to put bended text into two lines, you need to split text into two lines and add each line by `circos.text()` separately.  

```{r, fig.align='center'}
knitr::include_graphics("figures/Text-facing.PNG")
```

```{r, eval=FALSE}
circos.text(x, y, labels)
circos.text(x, y, labels, sector.index, track.index)
circos.text(x, y, labels, facing, niceFacing, adj, cex, col, font)
```

If, e.g., `facing` is set to `inside`, text which is on the bottom half of the circle is still facing to the top and hard to read. To make text more easy to read and not to hurt readers’ neck too much, `circos.text()` provides niceFacing option which automatically adjust text facing according to their positions in the circle. niceFacing only works for facing value of `inside`, `outside`, `clockwise`, `reverse.clockwise`, `bending.inside` and `bending.outside`.  

`adj` is internally passed to `text()`, thus, it actually adjusts text positions either horizontally or vertically (in the canvas coordinate).  

```{r, eval=FALSE}
circos.text(x, y, labels, adj = c(0, degree(5)), facing = "clockwise")
```

As `circos.text()` is applied in the data coordiante, offset can be directly added to x or/and y as a value measured in the data coordinate. An absolute offset can be set by using `ux()` (in x direction) and `uy()` (in y direction).  

```{r, eval=FALSE}
circos.text(x + ux(2, "mm"), y + uy(2, "mm"), labels)
```


## Rectangles and polygons  
Theoretically, circular rectangles and polygons are all polygons. If you imagine the plotting region in a cell as Cartesian coordinate, then `circos.rect()` draws rectangles. In the circle, the up and bottom edge become two arcs. Note this function can be vectorized.  
```{r, eval=FALSE}
circos.rect(xlef, ybottom, xright, ytop)
circos.rect(xleft, ybottom, xright, ytop, sector.index, track.index)
circos.rect(xleft, ybottom, xright, ytop, col, border, lty, lwd)
```

`circos.polygon()` draws a polygon through a series of points in a cell. Please note the first data point must overlap to the last data point.  

```{r, eval=FALSE}
circos.polygon(x, y)
circos.polygon(x, y, col, border, lty, lwd)
```


## Axes  
Mostly, we only draw x-axes on the circle. `circos.axis()` or `circos.xaxis()` privides options to customize x-axes which are on the circular direction. It supports basic functionalities as `axis()` such as defining the breaks and corresponding labels. Besides that, the function also supports to put x-axes to a specified position on y direction, to position the x-axes facing the center of the circle or outside of the circle, and to customize the axes ticks. The `at` and `labels` arguments can be set to a long vector that the parts which exceed the maximal value in the corresponding cell are removed automatically. The facing of labels text can be optimized by `labels.niceFacing` (by default it is `TRUE`).  

a: Major ticks are calculated automatically, other settings are defaults.  
b: Ticks are pointing to inside of the circle, facing of tick labels is set to outside.  
c: Position of x-axis is bottom in the cell.  
d: Ticks are pointing to the inside of the circle, facing of tick labels is set to reverse.clockwise.  
e: manually set major ticks and also set the position of x-axis.  
f: replace numeric labels to characters, with no minor ticks.  
g: No ticks for both major and minor, facing of tick labels is set to reverse.clockwise.  
h: Number of minor ticks between two major ticks is set to 2. Length of ticks is longer. Facing of tick labels is set to clockwise.  

```{r, fig.align='center'}
knitr::include_graphics("figures/x-axis.PNG")
```

As you may notice in the above figure, when the first and last axis labels exceed data ranges on x-axis in the corresponding cell, their positions are automatically adjusted to be shifted inwards in the cell.  

Possible usage of `circos.axis()` is as follows. Note `h` can be `bottom`, `top` or a numeric value.  
```{r, eval=FALSE}
circos.axis(h)
circos.axis(h, sector.index, track.index)
circos.axis(h, major.at, labels, major.tick, direction)
circos.axis(h, major.at, labels, major.tick, labels.font, labels.cex, labels.facing, labels.niceFacing)
circos.axis(h, major.at, labels, major.tick, minor.tick, major.tick.length, lwd)
```

Y-axis is also supported by `circos.yaxis()`. The usage is similar as `circos.axis()` One thing that needs to be note is users need to manually adjust `gap.degree` in `circos.par()` to make sure there are enough spaces for y-axes.  
```{r, eval=FALSE}
circos.yaxis(side)
circos.yaxis(at, labels, sector.index, track.index)
```


## Circular arrows  
Circular arrows can be used to represent stages in a circle. `circos.arrow()` draws circular arrows parallel to the circle. Since the arrow is always parallel to the circle, on x-direction, the start and end position of the arrow need to be defined while on the y-direction, only the position of the center of arrow needs to be defined. Also `width` controls the width of the arrow and the length is defined by `x2 - x1`. `arrow.head.width` and `arrow.head.length` control the size of the arrow head, and values are measured in the data coordinate in corresponding cell. `tail` controls the shape of the arrow tail. Note for `width`, `arrow.head.width` and `arrow.head.length`, the value can be set by `ux()`, `uy()` with absolute units.  

```{r}
circos.initialize(factors = letters[1:4], xlim = c(0, 1))
col = rand_color(4)
tail = c("point", "normal", "point", "normal")
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.arrow(x1 = 0, x2 = 1, y = 0.5, width = 0.4, 
        arrow.head.width = 0.6, arrow.head.length = ux(1, "cm"), 
        col = col[CELL_META$sector.numeric.index], 
        tail = tail[CELL_META$sector.numeric.index])
}, bg.border = NA, track.height = 0.4)
```

```{r}
circos.clear()
```


```{r}
cell_cycle <- data.frame(phase = factor(c("G1", "S", "G2", "M"), levels = c("G1", "S", "G2", "M")), 
                         hour = c(11, 8, 4, 1))
color = c("#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3")
circos.par(start.degree = 90)
circos.initialize(factors = cell_cycle$phase, xlim = cbind(rep(0, 4), cell_cycle$hour))
circos.track(ylim = c(0, 1), panel.fun = function(x, y){
  circos.arrow(x1 = CELL_META$xlim[1], x2 = CELL_META$xlim[2], 
               arrow.head.width = CELL_META$yrange*0.8, 
               arrow.head.length = ux(0.5, "cm"), 
               col = color[CELL_META$sector.numeric.index])
  
  circos.text(x = CELL_META$xcenter, y = CELL_META$ycenter, 
              labels = CELL_META$sector.index, 
              facing = "downward")
  
  circos.axis(h = 1, 
              major.at = seq(0, round(CELL_META$xlim[2])), 
              minor.ticks = 1, 
              labels.cex = 0.6)
}, bg.border = NA, track.height = 0.3)

circos.clear()
```

```{r, message=FALSE, warning=FALSE}
n = 500
df <- data.frame(fa = sample(letters[1:8], size = n, replace = T), 
                 x = runif(n), 
                 y = runif(n))

circos.par('track.height' = 0.1, 'start.degree' = 90, "gap.degree" = sample(1:8) %>% as.numeric())
circos.initialize(factors = df$fa, x = df$x)
circos.track(factors = df$fa, x = df$x, y = df$y, panel.fun = function(x, y){
  circos.text(x = get.cell.meta.data(name = "xcenter"), 
              y = get.cell.meta.data(name = "ycenter") + uy(7, "mm"), 
              labels = get.cell.meta.data(name = "sector.index"), 
              niceFacing = T)
  
  circos.points(x, y, pch = 16, cex = 0.5, 
                col = rep(c("red", "green"), 4)[get.cell.meta.data(name = "sector.numeric.index")])
  
  circos.axis(labels.cex = 0.5, labels.niceFacing = T)
})

# track 2
circos.trackHist(factors = df$fa, x = df$x)

# links  
cols <- rand_color(10)
for(i in 1:5){
  circos.link(sector.index1 = sample(letters[1:8], 1), point1 = sample(df$x, 2, replace = T), 
              sector.index2 = sample(letters[1:8], 1), point2 = sample(df$y, 1, replace = T), 
              col = cols[i], 
              directional = 1,
              border = "red", lty = 2)
}
circos.clear()
```


## Raster image  
`circos.raster()` is used to add a raster image at a certain position in the circle with proper rotation. The first input variable should be a `raster` object or an object that can be converted by `as.raster()`.  

Facing of the image is controlled by `facing` and `niceFacing` arguments which are similar as in `circos.text()`. When value of facing is one of `inside`, `outside`, `reverse.clockwise`, `clockwise` and `downward`, the size of raster image should have absolute values which should be specified in the form of `number- unit` such as `"20mm"`, `"1.2cm"` or `"0.5inche"`. If only one of `width` and `height` is specified, the other one is automatically calculated by using the aspect ratio of the original image.  
```{r}
library(png)

image <- system.file("extdata", "Rlogo.png", package = "circlize")
image <- as.raster(readPNG(image))
circos.par(start.degree = 90)
circos.initialize(factors = letters[1:5], 
                  xlim = c(0, 1))

all_facing_option <- c("inside", "outside", "reverse.clockwise", "clockwise", "downward")

circos.track(ylim = c(-1, 1), panel.fun = function(x, y){
  circos.raster(image = image, 
                x = CELL_META$xcenter, 
                y = CELL_META$ycenter, 
                width = "1cm", 
                facing = all_facing_option[CELL_META$sector.numeric.index])
  
  circos.text(x = CELL_META$xcenter, 
              y = CELL_META$ycenter, 
              labels = all_facing_option[CELL_META$sector.numeric.index], 
              facing = "inside", 
              niceFacing = TRUE)
})

circos.clear()
```

Also `facing` can be set to `bending.inside` and `bending.outside` that the image is filled to a circular rectangle. The strategy is to plot each original pixel as a small circular rectangle by `circos.rect()`, thus, the plotting is quite slow. If the original image is too huge, `scaling` argument can be set to reduce the size of the original image.  

```{r}
load(system.file("extdata", "doodle.RData", package = "circlize"))
circos.par("cell.padding" = c(0, 0, 0, 0))
circos.initialize(factors = letters[1:5], xlim = c(0, 1))
circos.track(ylim = c(0, 1), panel.fun = function(x, y){
  img = img_list[[CELL_META$sector.numeric.index]]
  circos.raster(image = img, x = CELL_META$xcenter, y = CELL_META$ycenter, 
                width = CELL_META$xrange, height = CELL_META$yrange, 
                facing = "bending.inside")
}, track.height = 0.25, bg.border = NA)

circos.track(ylim = c(0, 1), panel.fun = function(x, y){
  img = img_list[[CELL_META$sector.numeric.index + 16]]
  circos.raster(image = img, 
                x = CELL_META$xcenter, 
                y = CELL_META$ycenter, 
                width = CELL_META$xrange, 
                height = CELL_META$yrange, 
                facing = "bending.inside")
}, track.height = 0.25, bg.border = NA)

circos.clear()
```


## Links  
Links or ribbons are important part for the circular visualization. They are used to represent relations or interactions between sectors. In **circlize**, `circos.link()` draws links between single points and intervals. There are four mandatory arguments which are index for the first sector, positions on the first sector, index for the second sector and positions on the second sector. If the positions on the two sectors are all single points, the link represents as a line. If the positions on the two sectors are intervals, the link represents as a robbon.  

```{r, eval=FALSE}
circos.link(sector.index1, 0, sector.index2, 0)
circos.link(sector.index1, c(0,1), sector.index2, 0)
circos.link(sector.index1, c(0, 1), sector.index2, c(1, 2))
circos.link(sector.index1, c(0, 1), sector.index2, 0, col, lwd, lty, border)
```

The position of link end is controlled by rou. By default, it is the bottom of the most inside track and normally, you don’t need to care about this setting. The two ends of the link are located in a same circle by default. The positions of two ends can be adjusted with different values for rou1 and rou2 arguments.  

```{r, eval=FALSE}
circos.link(sector.index1, 0, sector.index2, 0, rou)
circos.link(sector.index1, 0, sector.index2, 0, rou1, rou2)
```

The height of the link is controlled by h argument. In most cases, you don’t need to care about the value of h because they are internally calculated based on the width of each link. However, when the link represents as a ribbon (i.e. link from point to interval or from interval to interval), It can not always ensure that one border is always below or above the other, which means, in some extreme cases, the two borders are intersected and the link would be messed up. It happens especially when position of the two ends are too close or the width of one end is extremely large while the width of the other end is too small. In that case, users can manually set height of the top and bottom border by h and h2.  

```{r, eval=FALSE}
circos.link(sector.index1, 0, sector.index2, 0, h)
circos.link(sector.index1, 0, sector.index2, 0, h, h2)
```

When there are many links, the height of all links can be systematically adjusted by `h.ratio`. The value is between 0 and 1.  

The border of link (if it is a ribbon) or the link itself (if it is a line) is in fact a quadratic Bezier curve, thus you can control the shape of the link by w and w2 (w2 controls the shape of bottom border).  
```{r, eval=FALSE}
circos.link(sector.index1, 0, sector.index2, 0, w)
circos.link(sector.index1, 0, sector.index2, 0, w, w2)
```

When the links represent as ribbons and the two ends overlap, the links will be de-generated as a ‘hill’.  

Links can have arrows to represent the directions. The `directional` argument controls how to add arrows. A value of 0 means there is no direction, `1` means the direction is from end 1 to end 2, `-1` means the direction is from end 2 to end 1, and `2` means bi-direction. If the link represents as a ribbon, a line with arrow will be added in the center of the link to represent directions.  

Type of arrows is controlled by `arr.type` argument and it is actually passed to `Arrowhead()` defined in **shape** package. Besides the arrow types supported in shape package, there is an additional arrow type `big.arrow` which turns the robbon into a big arrow.  
```{r, eval=FALSE}
circos.link(sector.index1, 0, sector.index2, 0, directional = 1)
circos.link(sector.index1, c(0, 1), sector.index2, c(0, 1), directional = -1)
```


## Highlight sector and tracks  
`draw.sector()` draws sectors, rings or their parts. This function is useful if you want to highlight some parts of your circular plot. it needs arguments of the position of circle center (by default c(0, 0)), the start degree and the end degree for sectors, and radius for two edges (or one edge) which are up or bottom borders. `draw.sector()` is independent from the circular plot.  

Possible usage of `draw.sector()` is as follows.  
```{r, eval=FALSE}
draw.sector(start.degree, end.degree, rou1)
draw.sector(start.degree, end.degree, rou1, rou2, center)
draw.sector(start.degree, end.degree, rou1, rou2, center, col, border, lwd, lty)
```

Directions from `start.degree` and `end.degree` is important for drawing sectors. By default, it is clock wise.  

```{r, eval=FALSE}
draw.sector(start.degree, end.degree, clock.wise = F)
```

Following code shows examples of `draw.sector()`.  

```{r}
par(mar = c(1, 1, 1, 1))
plot(c(-1, 1), c(-1, 1), type = "n", axes = F, ann = F, asp = 1)
draw.sector(start.degree = 20, end.degree = 0)
draw.sector(start.degree = 30, end.degree = 90, rou1 = 0.8, rou2 = 0.5, clock.wise = F, col = "#FF0080")
draw.sector(start.degree = 350, end.degree = 1000, col = "#00FF80", border = NA)
draw.sector(start.degree = 0, end.degree = 180, rou1 = 0.25, center = c(-0.5, 0.5), border = 2, lwd = 2)
draw.sector(start.degree = 0, end.degree = 360, rou1 = 0.7, rou2 = 0.6, col = "#0000FF80")
```

In order to highlight cells in the circular plot, we can use `get.cell.meta.data()` to get the information of positions of cells. E.g. the start degree and end degree can be obtained through `cell.start.degree` and `cell.end.degree`, and the position of the top border and bottom border can be obtained through `cell.top.radius` and `cell.bottom.radius`. Following code shows several examples to highlight sectors and tracks.  

First we create a circular plot with eight sectors and three tracks.  
```{r}
factors <- letters[1:8]
circos.initialize(factors = factors, xlim = c(0, 1))
for(i in 1:3){
  circos.track(ylim = c(0, 1))
}
circos.info(plot = TRUE)

# highlight sector a 
draw.sector(start.degree = get.cell.meta.data(name = "cell.start.degree", sector.index = "a"), 
            end.degree = get.cell.meta.data(name = "cell.end.degree", sector.index = "a"), 
            rou1 = get.cell.meta.data(name = "cell.top.radius", track.index = 1), 
            rou2 = get.cell.meta.data(name = "cell.bottom.radius", track.index = 3),
            col = "#FF000040")

# highlight track 2 and 3 in sector e and f
draw.sector(start.degree = get.cell.meta.data(name = "cell.start.degree", sector.index = "e"), 
            end.degree = get.cell.meta.data(name = "cell.end.degree", sector.index = "f"), 
            rou1 = get.cell.meta.data(name = "cell.top.radius", track.index = 2), 
            rou2 = get.cell.meta.data(name = "cell.bottom.radius", track.index = 3), 
            col = "#0000FF40")

# highlight specific regions  
pos <- circlize(x = c(0.2, 0.8), y = c(0.2, 0.8), 
                sector.index = "h", 
                track.index = 2)

draw.sector(start.degree = pos[1, "theta"], 
            end.degree = pos[2, "theta"], 
            rou1 = pos[1, "rou"], 
            rou2 = pos[2, "rou"], 
            clock.wise = TRUE, 
            col = "#00FFFF40")


# highlight track 1
draw.sector(start.degree = 0, end.degree = 360, 
            rou1 = get.cell.meta.data(name = "cell.top.radius", track.index = 1), 
            rou2 = get.cell.meta.data(name = "cell.bottom.radius", track.index = 1), 
            col = "#00FF0030")

circos.clear()
```

If the purpose is to simply highlight complete cells, there is a helper function `highlight.sector()` for which you only need to specify index for sectors and tracks that you want to to highlight. Paddings of the highligted regions can be set by `padding` argument which should contain four values representing ratios of the width or height of the highlighted region.  

One advantage of `highlight.sector()` is that it supports to add text in the highlighted regions. By default, the text is drawn at that center of the highlighted region. The position on the radical direction can be set by `text.vjust` argument either by a numeric value or a string in form of "2 inches"`` or“-1.2cm”`.   

```{r}
factors <- letters[1:8]
circos.initialize(factors = factors, xlim = c(0, 1))
for(i in 1:4){
  circos.track(ylim = c(0, 1))
}

circos.info(plot = T)

# highlight sector a and h in track 1
highlight.sector(sector.index = c("a", "h"), 
                 track.index = 1, 
                 text = "a and h belong to a same group", 
                 facing = "bending.inside", 
                 niceFacing = TRUE, 
                 text.vjust = "6mm", 
                 cex = 0.8)

# highlight sector 1
highlight.sector(sector.index = "c", 
                 col = "#0000FF40")

# highlight sector d 
highlight.sector(sector.index = "d", 
                 col = NA, 
                 border = "red", 
                 lwd = 2)

# highlight sector e  
highlight.sector(sector.index = "e", 
                 col = "#0000FF40", 
                 track.index = c(2, 3))

# highlight sector f and g
highlight.sector(sector.index = c("f", "g"), 
                 col = NA, 
                 border = "green", 
                 lwd = 2, 
                 track.index = c(2, 3), 
                 padding = c(0.1, 0.1, 0.1, 0.1))

# highlight track 4  
highlight.sector(sector.index = factors, 
                 col = "#FFFF0040", 
                 track.index = 4)

circos.clear()
```


## Work together with the base graphic system  
**circlize** is built on the base R graphic system, then, of course the base graphic functions can be used in combination with circlize functions. On the other hand, `circlize()` converts data points from the data coordinates to the canvas coordinates where the base graphic function can be directly applied.  

Normally, the base functions such as `title()`, `text()`, `legend()` can be used to add extra information on the plot.  

Sometimes, when the text or other graphics are far from the circle, you may set · so that the plotting is not clipped.  

```{r}
factors <- letters[1:4]
circos.initialize(factors = factors, 
                  xlim = c(0, 1))

circos.track(ylim = c(0, 1), panel.fun = function(x, y){
  circos.points(x = 1:20/20, y = 1:20/20)
})

text(x = 0, y = 0, labels = "This is\nthe center", cex = 1.5)
legend("bottomleft", pch = 1, legend = "This is the legend", bty = "n")
title(main = "This is the title")

circos.clear()
```


# Chapter 4 Legends  
**circlize** provides complete freedom for users to design their own graphics by implementing the self-defined function `panel.fun`. However one drawback arises that **circlize** is completely blind to users’ data so that one important thing is missing for the visualization which is the legend.  

```{r}
library(circlize)

col_fun <- colorRamp2(breaks = c(-2, 0, 2), c("green", "yellow", "red"))
circlize_plot <- function(){
  set.seed(12345)
  fa <- letters[1:10]
  circos.initialize(factors = fa, xlim = c(0, 1))
  circos.track(ylim = c(0, 1), panel.fun = function(x, y){
    circos.points(x = runif(20), y = runif(20), cex = 0.5, pch = 16, col = 2)
    circos.points(x = runif(20), y = runif(20), cex = 0.5, col = 3)
  })
  
  circos.track(ylim = c(0, 1), panel.fun = function(x, y){
    circos.lines(x = sort(runif(20)), y = runif(20), col = 4)
    circos.lines(x = sort(runif(20)), runif(20), col = 5)
  })
  
  for(i in 1:10){
    circos.link(sector.index1 = sample(fa, 1), point1 = sort(runif(10))[1:2], 
                sector.index2 = sample(fa, 1), point2 = sort(runif(10))[1:2], 
                col = add_transparency(col_fun(rnorm(1))))
  }
  circos.clear()
}
```

```{r}
library(ComplexHeatmap)

# discrete  
lgd_points <- Legend(at = c("label1", "label2"), type = "points", 
                     legend_gp = gpar(col = 2:3), title_position = "topleft", 
                     title = "Track1")

# discrete 
lgd_lines <- Legend(at = c("label3", "label4"), 
                    type = "lines", 
                    legend_gp = gpar(col = 4:5, lwd = 2), 
                    title_position = "topleft", 
                    title = "Track2")

# continuous  
lgd_links <- Legend(at = c(-2, -1, 0, 1, 2), 
                    col_fun = col_fun, 
                    title_position = "topleft",
                    title = "Links")

lgd_list_vertical <- packLegend(lgd_points, lgd_lines, lgd_links)
                                #, direction = c("vertical", "horizontal")
lgd_list_vertical
```

`lgd_points`, `lgd_lines`, `lgd_links` and `lgd_list_vertical` are all grob objects (graphical objects) defined by **grid** package, which you can think as boxes which contain all graphical elements for legends and they can be added to the plot by `grid.draw()`.  

**circlize** is implemented in the base graphic system while **ComplexHeatmap** is implemented by **grid** graphic system. However, these two systems can be mixed somehow. We can directly add grid graphics to the base graphics. (Actually they are two independent layers but drawn on a same graphic device.)  

```{r}
circlize_plot()
draw(object = lgd_list_vertical, 
     x = unit(4, "mm"), 
     y = unit(4, "mm"), 
     just = c("left", "bottom"))
```


# Chapter 5 Implement high-level circular plots  
## Circular barplots  
```{r}
category <- paste0("category", "_", 1:9)
percent <- sort(sample(40:80, 9))
color <- rev(rainbow(length(percent)))

library(circlize)
circos.par("start.degree" = 90, cell.padding = c(0, 0, 0, 0))
circos.initialize(factors = "a", xlim = c(0, 100))
# there is only one sector  

circos.track(ylim = c(0.5, length(percent) + 0.5), 
             track.height = 0.8, 
             bg.border = NA, 
             panel.fun = function(x, y){
               xlim = CELL_META$xlim 
               circos.segments(x0 = rep(xlim[1], 9), y0 = 1:9, 
                               x1 = rep(xlim[2], 9), y1 = 1:9, 
                               col = "#CCCCCC")
               
               circos.rect(xleft = rep(0, 9), ybottom = 1:9 - 0.45, 
                           xright = percent, 1:9 + 0.45, 
                           col = color, 
                           border = "white")
               
               circos.text(x = rep(xlim[1], 9), 1:9, 
                           labels = paste(category, " - ", percent, "%"), 
                           facing = "downward", 
                           adj = c(1.05, 0.5), 
                           cex = 0.8)
               breaks = seq(0, 85, by = 5)
               
               circos.axis(h = "top", 
                           major.at = breaks, 
                           labels = paste0(breaks, "%"), 
                           labels.cex = 0.6)
             })
circos.clear()
```


## Histograms  
circlize ships a `circos.trackHist()` function which draws histograms in cells. This function is a high-level function which caculates data ranges on y axes and creates a new track. The implement of this function is simple, that it first calculates the histogram in each cell by `hist()` function, then draws histogram by using `circos.rect()`.  

Users can choose to visualize data distributions by density lines by setting `draw.density = TRUE`.  

a histogram track with specified `bin.size` and a track with density lines. By default, bin size of histogram in each cell is calculated separatedly and they will be different between cells, which makes it not consistent to compare. Manually setting `bin.size` in all cells to a same value helps to compare the distributions between cells.  

```{r}
x <- rnorm(1600)
factors <- sample(x = letters[1:16], size = 1600, replace = TRUE)
circos.initialize(factors = factors, x = x)
circos.trackHist(factors = factors, x = x, col = "#999999", border = "#999999")
circos.trackHist(factors = factors, x = x, bin.size = 0.1, col = "#999999", border = "#999999")
circos.trackHist(factors = factors, x = x, draw.density = TRUE, col = "#999999", border = "#999999")
circos.clear()
```


## Phylogenetic trees  
Circular dendrograms have many applications, one of which is to visualize phylogenetic trees. Basically, a phylogenetic tree is a dendrogram which is a combination of lines. In R, there are several classes that describe such type of tree such as `hclust`, `dendrogram` and `phylo`. In this example, we will demonstrate how to draw the tree from the dendrogram class. Nevertheless, other classes can be converted to `dendrogram` without too much difficulty.  

The `bird.orders` data we are using here is from **ape** package. This data set is related to species of birds.  

As we mentioned before, the x-value for the phylogenetic tree is in fact index. Thus, the x-lim is just the minimum and maximum index of labels in the tree. Since there is only one phylogenetic tree, we only need one “big” sector.  

In the first track, we plot the name of each bird, with different colors to represent different sub trees.  

In the above code, setting `xlim` to `c(0, n)` is very important because the leaves of the dendrogram are drawn at `x = seq(0.5, n - 0.5)`.  

In the second track, we plot the circular dendrogram by `circos.dendrogram()`. You can render the dendrogram by **dendextend** package.    

We split the tree into six sub trees by `cutree()` and convert the data into a `dendrogram` object.    
```{r}
library(ape)
data(bird.orders)

hc <- as.hclust(bird.orders)
labels <- hc$labels # name of birds  
ct <- cutree(tree = hc, k = 6) # cut tree into 6 pieces  
n = length(labels)
dend <- as.dendrogram(object = hc)

circos.par(cell.padding = c(0, 0, 0, 0))
circos.initialize(factors = "a", xlim = c(0, n))

dend <- color_branches(dend, k = 6, col = 1:6)
dend_height <- attr(x = dend, which = "height")

circos.track(ylim = c(0, 1), 
             bg.border = NA, 
             track.height = 0.3, 
             panel.fun = function(x, y){
               for(i in seq_len(n)){
                 circos.text(x = i - 0.5, 
                             y = 0, 
                             labels = labels[i], 
                             adj = c(0, 0.5), 
                             facing = "clockwise", 
                             niceFacing = TRUE, 
                             col = ct[labels[i]], 
                             cex = 0.5)
               }
})

suppressPackageStartupMessages(library(dendextend))

circos.track(ylim = c(0, dend_height), 
             bg.border = NA, 
             track.height = 0.4, 
             panel.fun = function(x, y){
               circos.dendrogram(dend)
             })

circos.clear()
```


## Heatmaps  
Heatmaps, and sometimes combined with dendrograms are frequently used to visualize e.g. gene expression. Heatmaps are basically composed by rectangles, thus, they can be implemented by `circos.rect()`.  

In following example, we make a circular plot with two heatmaps. First we generate the two matrix and perform clustring on the two matrix.  

```{r}
mat <- matrix(data = rnorm(100*10), nrow = 10, ncol = 100)
col_fun <- colorRamp2(breaks = c(-2, 0, 2), 
                      colors = c("green", "black", "red"))
factors <- rep(x = letters[1:2], times = c(30, 70))
mat_list <- list(a = mat[, factors == "a"], 
                 b = mat[, factors == "b"])
dend_list <- list(a = as.dendrogram(hclust(d = dist(x = t(mat_list[["a"]])))), 
                  b = as.dendrogram(hclust(d = dist(x = t(mat_list[["b"]])))))

circos.par(cell.padding = c(0, 0, 0, 0), gap.degree = 2)
circos.initialize(factors = factors, xlim = cbind(c(0, 0), table(factors)))
circos.track(ylim = c(0, 10), bg.border = NA, panel.fun = function(x, y){
  sector.index = CELL_META$sector.index
  m <- mat_list[[sector.index]]
  dend <- dend_list[[sector.index]]
  
  m2 <- m[, order.dendrogram(dend)]
  col_mat <- col_fun(m2)
  nr <- nrow(m2)
  nc <- ncol(m2)
  for(i in 1:nr){
    circos.rect(xleft = 1:nc - 1, ybottom = rep(nr - i, nc),
                xright = 1:nc, ytop = rep(nr - i + 1, nc), 
                border = col_mat[i, ], 
                col = col_mat[i, ])
  }
})

max_height <- max(sapply(dend_list, function(x) attr(x, "height")))
circos.track(ylim = c(0, max_height), 
             bg.border = NA, 
             track.height = 0.3, 
             panel.fun = function(x, y){
               sector.index = get.cell.meta.data(name = "sector.index")
               dend <- dend_list[[sector.index]]
               circos.dendrogram(dend = dend, max_height = max_height)
             })

circos.clear()
```


# Chapter 6 Advanced layout  
## Zooming of sectors  
In this section, we will introduce how to zoom sectors and put the zoomed sectors at the same track as the original sectors.  

Under the default settings, width of sectors are calculated according to the data range in corresponding categories. Normally it is not a good idea to manually modify the default sector width since it reflects useful information of your data. However, sometimes manually modifying the width of sectors can make more advanced plots, e.g. zoomings.  

The basic idea for zooming is to put original sectors on part of the circle and put the zoomed sectors on the other part, so that in the original sectors, widths are still proportional to their data ranges, and in the zoomed sectors, the widths are also proportional to the data ranges in the zoomed sectors.  

This type of zooming is rather simple to implement. All we need to do is to copy the data which corresponds to the zoomed sectors, assign new category names to them and append to the original data. The good thing is since the data in the zoomed sectors is exactly the same as the original sectors, if you treat them as normal categories, the graphics will be exactly the same as in the original sectors, but with x direction zoomed.  

Following example shows more clearly the basic idea of this “horizontal” zooming.  

We first generate a data frame with six categories.  

```{r}
set.seed(123)
df <- data.frame(
  factors = sample(letters[1:6], 400, replace = TRUE), 
  x = rnorm(400),
  y = rnorm(400),
  stringsAsFactors = FALSE
)

# We want to zoom sector a and the first 10 points in sector b. First we extract these data and format as a new data frame.  
zoom_df_a <- df[df$factors == "a", ]
zoom_df_b <- df[df$factors == "b", ]
zoom_df_b <- zoom_df_b[order(zoom_df_b[, 2])[1:10], ]
zoom_df <- rbind(zoom_df_a, zoom_df_b)

# change the sector names in the zoomed data frame  
zoom_df$factors <- paste0("zoom_", zoom_df$factors)
df2 <- rbind(df, zoom_df)
```

```{r}
tapply(df2$x, df2$factors %>% as.factor, length)
```

You may notice the sum of the sector.width is not idential to 1. This is fine, they will be further normalized to 1 internally.

Strictly speaking, since the gaps between sectors are not taken into consideration, the width of the original sectors are not exactly 180 degree, but the real value is quite close to it.

```{r}
xrange <- tapply(df2$x, df2$factors, function(x) max(x) - min(x))
normal_sector_index <- unique(df$factors)
zoomed_sector_index <- unique(zoom_df$factors)
sector.width <- c(xrange[normal_sector_index] / sum(xrange[normal_sector_index]), 
                  xrange[zoomed_sector_index] / sum(xrange[zoomed_sector_index]))
sector.width
```

What to do next is just to make the circular plot in the normal way. All the graphics in sector a and b will be automatically zoomed to sector “zoom_a” and “zoom_b”.  

In following code, since the sector names are added outside the first track, `points.overflow.warning` is set to `FALSE` to turn off the warning messages.  

```{r}
circos.par(start.degree = 90, points.overflow.warning = FALSE)
circos.initialize(factors = df2$factors, x = df2$x, sector.width = sector.width)
circos.track(factors = df2$factors, x = df2$x, y = df2$y, 
             panel.fun = function(x, y){
  circos.points(x, y, col = "red", pch = 16, cex = 0.5)
  circos.text(x = CELL_META$xcenter, y = CELL_META$cell.ylim[2] + uy(2, 'mm'), 
              labels = CELL_META$sector.index, 
              sector.index = CELL_META$sector.index, 
              niceFacing = TRUE)
})

circos.link(sector.index1 = "a", point1 = get.cell.meta.data(nam = "cell.xlim", sector.index = "a"), 
            sector.index2 = "zoom_a", point2 = get.cell.meta.data(name = "cell.xlim", sector.index = "zoom_a"), 
            border = "NA", 
            col = "#00000020")

circos.link(sector.index1 = "b", point1 = c(zoom_df_a[1, 2], zoom_df_b[10, 2]), 
            sector.index2 = "zoom_b", point2 = get.cell.meta.data(name = "cell.xlim", sector.index = "zoom_b"), 
            rou1 = get.cell.meta.data(name = "cell.top.radius", sector.index = "b"), 
            border = NA, 
            col = "#00000020")

circos.clear()
```


## Visualize part of the circle  
`canvas.xlim` and `canvas.ylim` parameters in `circos.par()` are useful to generate plots only in part of the circle. As mentioned in previews chapters, the circular plot is always drawn in a canvas where x values range from -1 to 1 and y values range from -1 to 1. Thus, if `canvas.xlim` and `canvas.ylim` are all set to `c(0, 1)`, which means, the canvas is restricted to the right top part, then only sectors between 0 to 90 degree are visible.  

```{r}
df <- data.frame(
  factors = "a", 
  x = runif(100), 
  y = runif(100)
)

circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1), 
           "start.degree" = 90, "gap.after" = 270)

factors <- "a"
circos.initialize(factors = df$factors, x = df$x)
circos.track(factors = df$factors, y = df$y, panel.fun = function(x, y){
  circos.points(x = df$x, y = df$y, col = "red", pch = 19, cex = 0.3)
})

circos.track(factors = df$factors, x = df$x, y = df$y, 
             panel.fun = function(x, y){
               circos.lines(x = df$x, df$y, type = "h")
             })

circos.clear()
```

```{r}
factors <- letters[1:4]

df <- data.frame(
  factors = rep("a", 100), 
  x = runif(n = 100), 
  y = runif(n = 100)
) 

# track 1
circos.initialize(factors = factors, xlim = range(df$x))
circos.track(factors = factors, ylim = range(df$y), panel.fun  = function(x, y){
  circos.points(x = df$x, y = df$y, pch = 16, cex = 0.5, sector.index = "a")
})

# track 2
circos.track(ylim = range(df$y), bg.border = NA)
circos.update(sector.index = "a", bg.border = "black")
circos.points(x = df$x, y = df$y, pch = 16, cex = 0.5)

# track 3 and 4
circos.track(factors = factors, ylim = range(df$y))
circos.track(factors = factors, ylim = range(df$y))

circos.clear()
```

**draw circular in circlize package**  
```{r}
circos.par(gap.degree = 0)
circos.initialize(factors = "a", xlim = c(0, 1))
circos.track(factors = "a", ylim = c(0, 1), track.height = 0.05, bg.col = "black", bg.border = "black")
circos.clear()
```

**circlize** finally makes the circular plot in the base R graphic system. Seperated circular plots actually can be put in a same page by some tricks from the base graphic system. Here the key is `par(new = TRUE)` which allows to draw a new figure as a new layer directly on the previous canvas region. By setting different `canvas.xlim` and `canvas.ylim`, it allows to make more complex plots which include more than one circular plots.  

Folowing code shows how the two independent circualr plots are added and nested. Figure 6.4 illustrates the invisible canvas coordinate and how the two circular plots overlap.  

```{r}
factors <- letters[1:4]
circos.initialize(factors = factors, xlim =  c(0, 1))
circos.track(ylim = c(0, 1), panel.fun = function(x, y){
  circos.text(x = 0.5, y = 0.5, labels = "outer circos", niceFacing = TRUE)
})

circos.clear()

par(new = TRUE) # magic 
circos.par("canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
factors <- letters[1:3]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.track(ylim = c(0, 1), panel.fun = function(x, y){
  circos.text(x = 0.5, y = 0.5, labels = "inner circos", niceFacing = T)
})

circos.clear()
```


```{r}
par(mar= rep(0, 4))
circos.par(start.degree = 45, "canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
circos.initialize(factors = letters[1:4], xlim = c(0, 1))
circos.track(factors = letters[1:4], ylim = c(0, 1), bg.border = NA,
             panel.fun = function(x, y){
})
circos.update(sector.index = "d", track.index = 1, bg.col = NA, bg.border = "black")
circos.text(x = CELL_META$xcenter, 
            y = CELL_META$ycenter, 
            labels = "first", 
            niceFacing = T)
circos.update(sector.index = "a", track.index = 1, bg.col = NA, bg.border = "black")
circos.text(x = CELL_META$xcenter, 
            y = CELL_META$ycenter, 
            labels = "first", 
            niceFacing = T)

circos.clear()

par(new = TRUE)

circos.par("canvas.xlim" = c(-1.5, 2.5), "canvas.ylim" = c(-1.5, 2.5), start.degree = 45)
circos.initialize(factors = letters[1:4], xlim = c(0, 1))
circos.track(factors = letters[1:4], ylim = c(0, 1), bg.border = NA,
             panel.fun = function(x, y){
})

circos.update(sector.index = "b", track.index = 1, bg.border = "black")
circos.text(x = CELL_META$xcenter, 
            y = CELL_META$ycenter, 
            labels = "second", 
            niceFacing = T)
circos.update(sector.index = "c", track.index = 1, bg.border = "black")
circos.text(x = CELL_META$xcenter, 
            y = CELL_META$ycenter, 
            labels = "second", 
            niceFacing = T)

circos.clear()
```


```{r}
factors <- letters[1:4]
lim = c(1, 1.1, 1.2, 1.3)

for(i in 1:4){
  circos.par("canvas.xlim" = c(-lim[i], lim[i]), "canvas.ylim" = c(-lim[i], lim[i]))
  circos.initialize(factors = factors, xlim = c(0, 1))
  circos.track(ylim = c(0, 1), bg.border = NA)
  circos.update(sector.index = factors[i], bg.border = "black")
  circos.points(x = runif(10), 
                y = runif(10), 
                pch = 16, 
                cex = 0.5)
  circos.clear()
  par(new = TRUE)
}
```


## Arrange multiple plots  
**circlize** is implemented in the base R graphic system, thus, you can use `layout()` or `par(mforw, mfcol)` to arrange multiple circular plots in one page.  
```{r}
layout(mat = matrix(1:9, 3, 3))
for(i in 1:9){
  factors = 1:8
  par(mar = rep(0.5, 4))
  circos.par(cell.padding = rep(0, 4))
  circos.initialize(factors = factors, xlim = c(0, 1))
  circos.track(ylim = c(0, 1), track.height = 0.05, bg.col = rand_color(8), bg.border = NA)
  for(i in 1:10){
    se = sample(1:8, 2)
    circos.link(sector.index1 = se[1], point1 = runif(2), 
                sector.index2 = se[2], point2 = runif(2), 
                col = rand_color(1, transparency = 0.4), border = NA)
  }
  circos.clear()
}
```
 

# Chapter 7 Introduction  
Circular visualization is popular in Genomics and related omics fields. It is efficient in revealing associations in high dimensional genomic data. In genomic plots, categories are usually chromosomes and data on x axes are genomic positions, but it can also be any kind of general genomic categories.  

To make is easy for Genomics analysis, circlize package particularly provides functions which focus on genomic plots. These functions are synonymous to the basic graphic functions but expect special format of input data.  

+ `circos.genomicTrack()`: create a new track and add graphics.  
+ `circos.genomicPoints()`: low-level function, add points.  
+ `circos.genomicLines()`: low-level function, add lines or segments.  
+ `circos.genomicRect()`: low-level function, add rectangles.  
+ `circos.genomicText()`: low-level function, add text.  
+ `circos.genomicLink()`: add links.  

The genomic functions are implemented by basic circlize functions (e.g. `circos.track()`, `circos.points()`), thus, the use of genomic functions can be mixed with the basic circlize functions.  

## Input data  
Genomic data is usually stored as a table where the first three columns define the genomic regions and following columns are values associated with the corresponding regions. Each genomic region is composed by three elements: genomic category (in most case, it is the chromosome), start position on the genomic category and the end position. Such data structure is known as BED format and is broadly used in genomic research.  

**circlize** provides a simple function `generateRandomBed()` which generates random genomic data. Positions are uniformly generated from human genome and the number of regions on chromosomes approximately proportional to the length of chromosomes. In the function, `nr` and `nc` control the number of rows and numeric columns that users need. Please note `nr` are not exactly the same as the number of rows which are returned by the function. `fun` argument is a self-defined function to generate random values.  

```{r}
set.seed(999)
bed <- generateRandomBed()
head(bed)
```

```{r}
bed <- generateRandomBed(nr = 200, nc = 4)
nrow(bed)
```

```{r}
bed <- generateRandomBed(nc = 2, fun = function(k)sample(letters, k, replace = TRUE))
head(bed)
```

All genomic functions in **circlize** expect input variable as a data frame which contains genomic data or a list of data frames which contains genomic data in different conditions.  


# Chapter 8 Initialize with genomic data  
## Initialize with cytoband data  
Cytoband data is an ideal data source to initialize genomic plots. It contains length of chromosomes as well as so called “chromosome band” annotation to help to identify positions on chromosomes.  

### Basic usage  
If you work on human genome, the most straightforward way is to directly use `circos.initializeWithIdeogram()`. By default, the function creates a track with chromosome name and axes, and a track of ideograms.  

Although chromosome names added to the plot are pure numeric, actually the internally names have the “chr” index. When you adding more tracks, the chromosome names should also have “chr” index.  
```{r}
circos.initializeWithIdeogram()
text(x = 0, y = 0, labels = "default", cex = 1)
```

```{r}
circos.info()
```

```{r}
circos.clear()
```

By default, `circos.initializeWithIdeogram()` initializes the plot with cytoband data of human genome `hg19`. Users can also initialize with other species by specifying `species` argument and it will automatically download cytoband files for corresponding species.  
```{r}
par(mfrow = c(1, 2))
circos.initializeWithIdeogram(species = "hg38")
circos.initializeWithIdeogram(species = "mm10")
```

When you are dealing rare species and there is no cytoband data available yet, `circos.initializeWithIdeogram()` will try to continue to download the “chromInfo” file form UCSC, which also contains lengths of chromosomes, but of course, there is no ideogram track on the plot.  

In some cases, when there is no internet connection for downloading or there is no corresponding data avaiable on UCSC yet. You can manually construct a data frame which contains ranges of chromosomes or a file path if it is stored in a file, and sent to `circos.initializeWithIdeogram()`.  

```{r}
cytoband.file <- system.file("extdata", "cytoBand.txt", package = "circlize")
circos.initializeWithIdeogram(cytoband = cytoband.file)
```

```{r}
cytoband.file <- read.table(file = cytoband.file, 
                            colClasses = c("character", "numeric", "numeric", "character", "character"), 
                            sep = "\t")
circos.initializeWithIdeogram(cytoband = cytoband.file)
```

```{r}
circos.info()
```

If you read cytoband data directly from file, please explicitly specify `colClasses` arguments and set the class of position columns as `numeric`. The reason is since positions are represented as integers, read.table would treat those numbers as `integer` by default. In initialization of circular plot, circlize needs to calculate the summation of all chromosome lengths. The summation of such large integers would throw error of integer overflow.  

By default, `circos.intializeWithIdeogram()` uses all chromosomes which are available in cytoband data to initialize the circular plot. Users can choose a subset of chromosomes by specifying `chromosome.index`. This argument is also for ordering chromosomes.  

```{r}
circos.initializeWithIdeogram(chromosome.index = paste0("chr", c(3, 5, 2, 8)))
text(0, 0, labels = "subset of chromosomes", cex = 1)
```

```{r}
circos.clear()
```

When there is no cytoband data for the specified species, and when chromInfo data is used instead, there may be many many extra short contigs. `chromosome.index` can also be useful to remove unnecessary contigs.  


### Pre-defined tracks  
After the initialization of the circular plot, `circos.initializeWithIdeogram()` additionally creates a track where there are genomic axes and chromosome names, and create another track where there is an ideogram (depends on whether cytoband data is available). `plotType` argument is used to control which type of tracks to add.  

```{r}
par(mfrow = c(1, 2))

circos.initializeWithIdeogram(plotType = c("axis", "labels"))
text(x = 0, y = 0, labels = 'c("axis", "labels")', cex = 1)

circos.initializeWithIdeogram(plotType = NULL)
text(x = 0, y = 0, labels = "plotType = NULL", cex = 1)
```

```{r}
circos.clear()
```


### Other general settings  
Similar as general circular plot, the parameters for the layout can be controlled by `circos.par()`. Do remember when you explicitly set circos.par(), you need to call circos.clear() to finish the plotting.  

```{r}
par(mfrow = c(1, 2))
circos.par("start.degree" = 90)
circos.initializeWithIdeogram()
circos.clear()
text(x = 0, y = 0, labels = "'start.degree' = 90", cex = 1)

circos.par("gap.degree" = rep(c(2, 4), 12))
circos.initializeWithIdeogram()
circos.clear()
text(x = 0, y = 0, "'gap.degree' = rep(c(2, 4), 12)", cex = 0.5)
```

## Customize chromosome track  
By default `circos.initializeWithIdeogram()` initializes the layout and adds two tracks. When `plotType` argument is set to `NULL`, the circular layout is only initialized but nothing is added. This makes it possible for users to completely design their own style of chromosome track.  

In the following example, we use different colors to represent chromosomes and put chromosome names in the center of each cell.  

```{r}
set.seed(123)
circos.initializeWithIdeogram(plotType = NULL)
circos.track(ylim = c(0, 1), panel.fun = function(x, y){
  chr = CELL_META$sector.index
  xlim = CELL_META$xlim
  ylim = CELL_META$ylim
  circos.rect(xleft = xlim[1], ybottom = 0, 
              xright = xlim[2], ytop = 1, 
              col = rand_color(1))
  
  circos.text(x = mean(xlim), y = mean(ylim), labels = chr, 
              cex = 0.5, col = "white", 
              facing = "inside", niceFacing = TRUE)
}, track.height = 0.15, bg.border = NA)
```

```{r}
circos.clear()
```


## Initialize with general genomic category  
Chromosome is just a special case of genomic category. `circos.genomicInitialize()` can initialize circular layout with any type of genomic categories. In fact, `circos.initializeWithIdeogram()` is implemented by `circos.genomicInitialize()`. The input data for `circos.genomicInitialize()` is also a data frame with at least three columns. The first column is genomic category (for cytoband data, it is chromosome name), and the next two columns are positions in each genomic category. The range in each category will be inferred as the minimum position and the maximum position in corresponding category.  

In the following example, a circular plot is initalized with three genes.  
```{r}
df <- data.frame(
  name = c("TP53", 'TP63', "TP73"), 
  start = c(7565097, 189349205, 3569084), 
  end = c(7590856, 189615068, 3652765)
)

circos.genomicInitialize(df)
```

Note it is not necessary that the record for each gene is only one row.  

In following example, we plot the transcripts for TP53, TP63 and TP73 in a circular layout.  
```{r}
tp_family <- readRDS(file = system.file(package = "circlize", "extdata", "tp_family_df.rds"))
head(tp_family)
```

In the following code, we first create a track which identifies three genes.  
```{r}
circos.genomicInitialize(tp_family)
circos.track(ylim = c(0, 1), 
             bg.col = c("#FF000040", "#00FF0040", "#0000FF40"), 
             bg.border = NA, 
             track.height = 0.05)

# put transcripts one after the other for each gene.
n <- max(tapply(tp_family$transcript, tp_family$gene, FUN = function(x) length(unique(x))))
circos.genomicTrack(data = tp_family, ylim = c(0.5, n + 0.5), panel.fun = function(region, value, ...){
  all_tx = unique(value$transcript)
  for(i in seq_along(all_tx)){
    l = value$transcript == all_tx[i]
    # for each transcript  
    current_tx_start = min(region[l, 1])
    current_tx_end = max(region[l, 2])
    
    circos.lines(x = c(current_tx_start, current_tx_end), 
                 y = c(n - i + 1, n - i + 1), 
                 col = "#CCCCCC")
    
    circos.genomicRect(region = region[l, , drop = F], 
                       ytop = n - i + 1 + 0.4, 
                       ybottom = n - i + 1 -0.4, 
                       col = "orange", 
                       border = NA)
  }
}, bg.border = NA, track.height = 0.4)

circos.clear()
```

you may notice the start of axes becomes “0KB” while not the original values. It is just an adjustment of the axes labels to reflect the relative distance to the start of each gene, while the coordinate in the cells are still using the original values. Set tickLabelsStartFromZero to FALSE to recover axes labels to the original values.  

## Zooming chromosomes  
We first define a function extend_chromosomes() which copy data in subset of chromosomes into the original data frame.  
```{r}
extend_chromosomes <- function(bed, chromosome, prefix = "zoom_"){
  zoom_bed = bed[bed[[1]] %in% chromosome, , drop = F]
  zoom_bed[[1]] = paste0(prefix, zoom_bed[[1]])
  rbind(bed, zoom_bed)
}
```

We use `read.cytoband()` to download and read cytoband data from UCSC. In following, x ranges for normal chromosomes and zoomed chromosomes are normalized separetely.  

```{r}
cytoband <- read.cytoband()
cytoband_df <- cytoband$df
chromosome <- cytoband$chromosome

xrange <- c(cytoband$chr.len, cytoband$chr.len[c("chr1", "chr2")])
normal_chr_index <- 1:24
zoomed_chr_index <- 25:26

# normalize in normal chromosomes and zoomed chromosomes separately  
sector.width <- c(xrange[normal_chr_index] / sum(xrange[normal_chr_index]), 
                  xrange[zoomed_chr_index] / sum(xrange[zoomed_chr_index]))
```

The extended cytoband data which is in form of a data frame is sent to `circos.initializeWithIdeogram()`. You can see the ideograms for chromosome 1 and 2 are zoomed.  

```{r}
circos.par(start.degree = 90)
circos.initializeWithIdeogram(extend_chromosomes(bed = cytoband_df, chromosome = c("chr1", "chr2")), 
                              sector.width = sector.width)


# add a new track 
bed <- generateRandomBed(nr = 500)
circos.genomicTrack(extend_chromosomes(bed = bed, chromosome = c("chr1", "chr2")), 
                    panel.fun = function(region, value, ...){
  circos.genomicPoints(region, value, pch = 16, cex = 0.3)
                    })

# add a link 
circos.link(sector.index1 = "chr1", point1 = get.cell.meta.data(name = "cell.xlim", sector.index = "chr1"), 
            sector.index2 = "zoom_chr1", point2 = get.cell.meta.data(name = "cell.xlim", sector.index = "zoom_chr1"), 
            col = "#00000020")

circos.clear()
```


# Chapter 9 Create plotting regions for genomic data  
Tracks are created and graphics are added by `circos.genomicTrackPlotRegions()`, or the short version `circos.genomicTrack()`. In following examples, chromosome will be used as the genomic category, and we assume `data` is simply a `data` frame in BED format (where the first column is the chromosome name, the second and third column are start and end positions, and the following columns are associated values).  

Similae as `circos.track()`, `circos.genomicTrack()` also accepts a self-defined function `panel.fun` which is applied in every cell but with different form.  
```{r,eval=FALSE}
circos.genomicTrackPlotRegion(data, panel.fun = function(region, value, ...){
  circos.genomicPoints(region, value, ...)
})
```

Inside `panel.fun`, users can use low-level graphic functions to add basic graphics in each cell. `panel.fun` expects two arguments `region` and `value` which are automatically processed and passed from `circos.genomicTrack()`. `region` is a two-column data frame which only contains start position and end position in the current chromosome. **`value` is also a data frame which contains other columns (start for the fourth column, if it exists)**. Thus, basically, region can be thought as values on x axes and value as values on y axes.  

There should be a third arguments ... which is mandatory and is used to pass user- invisible variables to inner functions and make magics.  

So whenever you use panel.fun in circos.genomicTrack(), please add it to the end of your function.  

```{r}
bed <- generateRandomBed(nc = 2)
```

```{r}
circos.initializeWithIdeogram(plotType = NULL)
circos.genomicTrackPlotRegion(data = bed, panel.fun = function(region, value, ...){
  if(CELL_META$sector.index == "chr1"){
    print(head(region, n = 2))
    print(head(value, n = 2))
  }
})
```
 
Since `circos.genomicTrack()` creates a new track, it needs values to calculate data ranges on y direction. Users can either specify the index of numeric columns in `data` by `numeric.column` (named index or numeric index, it can also be a vector with more than one columns) or directly set `ylim`. If none of them are set, the function will try to look for all numeric columns in `data` (of course, excluding the first three columns), and set them as `numeric.column`.  

```{r}
circos.genomicTrackPlotRegion(data, ylim = c(0, 1), 
                              panel.fun = function(region, value, ...){
                                circos.genomicPoints(region, value, ...)
                              })

circos.genomicTrackPlotRegion(data, numeric.column = c("value1", "value2"), 
                              panel.fun = function(region, value, ...){
                                circos.genomicPoints(region, value, ...)
                              })
```

Since genomic functions are implemented by basic circlize functions, you can use `circos.info()` anywhere to get information of sectors and tracks.  

As you already see in previous examples, circlize also provides low-level graphic functions specifically designed for genomic data. They are all implemented by corresponding normal circlize functions, but needs input variables with special format.  

## Points  
Usage of `circos.genomicPoints()` is similar as `circos.points()`. `circos.genomicPoints()` expects a two-column data frame which contains genomic regions and a data frame containing corresponding values. Points are always drawn at the middle of each region. The data column of the y values for plotting should be specified by `numeric.column`. If `numeric.column` has length larger than one, all the specified columns will be used for adding points.  

If the function is called inside `circos.genomicTrack()` and users have been already set `numeric.column` in `circos.genomicTrack()`, proper value of `numeric.column` will be passed to `circos.genomicPoints()` through ... in `panel.fun`, which means, you must add ... as the final argument in `circos.genomicPoints()` to get such information. If `numeric.column` is not set in both places, `circos.genomicPoints()` will use all numeric columns detected in `value`.  

Note here numeric.column is measured in value while numeric.column in circos.genomicTrack() is measured in the complete data frame. There is a difference of 3 for the column index! When numeric.column is passed to circos.genomicPoints() internally, 3 is subtracted automatically. If you use character index instead of numeric index, you do not need to worry about it.  

Possible usages of `circos.genomicPoints()` are as follows.  
```{r}
circos.genomicPoints(region, value, numeric.column = c(1, 2))
circos.genomicPoints(region, value, cex, pch)
circos.genomicPoints(region, value, sector.index, track.index)
circos.genomicTrack(data, numeric.column = 4, 
                    panel.fun = function(region, value, ...){
                      # numeric.column is automatically passed to 'circos.genomicPoints()'
                      circos.genomicPoints(region, value, ...)
                    })
```

If there is only one numeric column, graphical parameters such as `pch`, `cex` can be of length one or number of rows of `region`. If there are more than one numeric columns specified, points for each numeric column will be added iteratively, and the graphical parameters should be either length one or number of numeric columns specified.  

`circos.genomicPoints()` is simply implemented by `circos.points()`. The basic idea of the implementation is shown as following code, so, if you don’t like the `circos.genomic*()` functions, it would not be difficult to directly use the `circos.*()` functions.  

```{r, eval=FALSE}
circos.genomicPoints(function(region, value, numeric.column = 1, ...){
  x = (region[[2]] + region[[1]]) / 2
  for(i in numeric.column){
    y = value[[i]]
    circos.points(x, y, ...)
  }
}
```


## Lines  
`circos.genomicLines()` is similar as `circos.lines()`. The setting of graphical parameters is similar as `circos.genomicPoints()`.  

```{r, eval=FALSE}
circos.genomicLines(region, value, ...)
circos.genomicLines(region, value, numeric.column = c(1, 2))
circos.genomicLines(region, value, area, baseline, border)
circos.genomicLines(region, value, sector.index, track.index)
```

**circlize** additionally provides a new option `segment` for `lty` by which each genomic regions represent as ‘horizontal’ lines at y positions.  
```{r, eval=FALSE}
circos.genomicLines(region, value, lwd, lty = "segment")
```

## Text 
For `circos.genomicText()`, the position of text can be specified either by `numeric.column` or a separated vector `y`. The labels of text can be specified either by `labels.column` or a vector `labels`.  
```{r, eval=FALSE}
circos.genomicText(region, value, ...)
circos.genomicText(region, value, ...)
circos.genomicText(region, value, numeric.column, labels.column)
circos.genomicText(region, value, facing, niceFacing, adj)
circos.genomicText(region, value, sector.index, track.index)
```


## Rectangles  
For `circos.genomicRect()`, Since the left and right of the rectangles are already determined by the start and end of the genomic regions, we only need to set the positions of top and bottom of the rectangles by specifying `ytop`, `ybottom` or `ytop.column`, `ybottom.column`.  

```{r, eval=FALSE}
circos.genomicRect(region, value, ytop = 1, ybottom = 0)
circos.genomicText(region, value, ytop.column = 2, ybottom = 0)
circos.genomicRect(region, value, col, border)
```
 

## Links  
`circos.genomicLink()` expects two data frames and it adds links from genomic regions in the first data frame to corresponding genomic regions in the second data frame. All additional arguments are passed to `circos.link()`.  
```{r}
set.seed(123)
bed1 <- generateRandomBed(nr = 100)
bed1 <- bed1[sample(nrow(bed1), 20), ]
bed2 <- generateRandomBed(nr = 100)
bed2 <- bed2[sample(nrow(bed2), 20), ]

circos.initializeWithIdeogram()
circos.genomicLink(region1 = bed1, region2 = bed2, 
                   col = rand_color(nrow(bed1), transparency = 0.5), 
                   border = NA)

circos.clear()
```


## Mixed use of eneral circlize functions  
`panel.fun` is applied on each cell, which means, genomic graphic functions, you can also use general circlize functions to add more graphics. For example, some horizontal lines and are added to each cell and axes are put on top of each cell.  
```{r, eval=FALSE}
circos.genomicTrack(bed, ylim = c(-1, 1), 
                    panel.fun = function(region, value, ...){
                      circos.genomicPoints(region, value, ...)
                      for(h in c(-1, -0.5, 0, 0.5, 1)){
                        circos.lines(x = CELL_META$cell.xlim, 
                                     y = c(0, 0), 
                                     lty = 2, 
                                     col = "grey")
                      }
                      circos.text(x, y, labels)
                      circos.axis(h = "top")
                    })
```

# Chapter 10 modes for `circos.genomicTrack()`  
The behaviour of `circos.genomicTrack()` and `panel.fun` will be different according to different input data (e.g. is it a simple data frame or a list of data frames? If it is a data frame, how many numeric columns it has?) and different settings.  

## Normal mode  
### Input is a data frame  
If input `data` is a data frame in BED format, `region` in `panel.fun` would be a data frame containing start position and end position in the current chromosome which is extracted from `data`. `value` is also a data frame which contains columns in `data` excluding the first three columns. Index of proper numeric columns will be passed by `...` if it is set in `circos.genomicTrack()`. If users want to use such information, they need to pass `...` to low-level genomic function such as `circos.genoimcPoints()` as well.  

If there are more than one numeric columns, graphics are added for each column repeatedly (with same genomic positions).  

```{r, eval=FALSE}
data <- generateRandomBed(nc = 2)
circos.genomicTrack(data, numeric.column = 4, panel.fun = function(region, value, ...){
  circos.genomicPoints(region, value, ...)
  circos.genomicPoints(region, value)
  
  # 1st column in 'value' while 4th column in 'data'  
  circos.genomicPoints(region, value, numeric.column = 1)
})
```


### Input is a list of data frames  
If input data is a list of data frames, `panel.fun` is applied on each data frame iteratively to the current cell. Under such condition, `region` and `value` will contain corresponding data in the current data frame and in the current chromosome. The index for the current data frame can be get by `getI(...)`. Note `getI(...)` can only be used inside `panel.fun` and `...` argument is mandatory.  

When `numeric.column` is specified in `circos.genomicTrack()`, the length of `numeric.column` can only be one or the number of data frames, which means, there is only one numeric column that will be used in each data frame. If it is not specified, the first numeric column in each data frame is used.  

```{r, eval=FALSE}
bed_list <- list(
  generateRandomBed(), 
  generateRandomBed()
)

circos.genomicTrack(bed_list, panel.fun = function(region, value, ...){
  i = getI(...)
  circos.genomicPoints(region, value, col = i, ...)
})

# column 4 in the first bed and column 5 in the second bed 
circos.genomicTrack(bed_list, numeric.column = c(4, 5), 
                    panel.fun = function(region, value, ...){
                      i = getI(...)
                      circos.genomicPoints(region, value, col = i, ...)
                    })
```


## Stack mode  
`circos.genomicTrack()` also supports a `stack` mode by setting `stack = TRUE`. Under `stack` mode, `ylim` is re-defined inside the function and the y-axis is splitted into several bins with equal height and graphics are put onto “horizontal” bins (with position `y = 1, 2, ...`).  

### Input is a data frame  
Under `stack` mode, when input data is a single data frame containing one or more numeric columns, each numeric column defined in `numeric.column` will be treated as a single unit (recall that when `numeric.column` is not specified, all numeric columns are used). `ylim` is re-defined to `c(0.5, n+0.5)` in which `n` is number of numeric columns specified. `panel.fun` is applied iteratively on each numeric column and add graphics to the horizontal line `y = i`. In this case, actually value in e.g. `circos.genomicPoints()` doesn’t used for mapping the y positions, while replaced with `y = i` internally.  

In each iteration, in `panel.fun`, `region` is still the genomic regions in current chromosome, but `value` only contains current numeric column plus all non-numeric columns. The value of the index of “current” numeric column can be obtained by `getI(...)`.  

```{r, eval=FALSE}
daat <- generateRandomBed(nc = 2)
circos.genomicTrack(data, stack  =TRUE, 
                    panel.fun = function(region, value, ...){
                      i = getI(...)
                      circos.genomicPoints(region, value, col = i, ...)
                    })
```


### Input is a list of data frames  
When input data is a list of data frames, each data frame will be treated as a single unit. `ylim` is re-defined to `c(0.5, n+0.5)` in which `n` is the number of data frames. `panel.fun` will be applied iteratively on each data frame. In each iteration, in `panel.fun`, `region` is still the genomic regions in current chromosome, and `value` contains columns in current data frame excluding the first three columns. Graphics by low-level genomic functions will be added on the `horizontal’ bins.  
```{r, eval=FALSE}
bed_list <- list(generateRandomBed(), generateRandomBed())
circos.genomicTrack(bed_list, stack = TRUE, 
                    panel.fun = function(region, value, ...){
                      i = getI(...)
                      circos.genomicPoints(region, value, ...)
                    })
```

Under stack mode, if using a data frame with multiple numeric columns, graphics on all horizontal bins share the same genomic positions while if using a list of data frames, the genomic positions can be different.  

## Applications  
In this section, we will show several real examples of adding genomic graphics under different modes. Again, if you are not happy with these functionalities, you can simply re-implement your plot with the basic circlize functions.  

### Points  
To make plots more clear to look at, we only add graphics in the first quarter of the circle and initialize the plot only with chromosome 1.  
```{r}
set.seed(999)
circos.par("track.height" = 0.1, 'start.degree' = 90, 
           canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), 
           gap.degree = 270)

circos.initializeWithIdeogram(chromosome.index = "chr1", plotType = NULL)

# track A
bed <- generateRandomBed(nr = 300)
circos.genomicTrack(bed, panel.fun = function(region, value, ...){
  circos.genomicPoints(region, value, pch = 16, cex = 0.5, ...)
})

# track B
circos.genomicTrack(bed, stack = TRUE, 
                    panel.fun = function(region, value, ...){
                      circos.genomicPoints(region, value, pch = 16, cex = 0.5, ...)
                      i = getI(...)
                      circos.lines(x = CELL_META$cell.xlim, 
                                   y = c(i, i), 
                                   lty = 2, 
                                   col = "#00000040")
                    })

# track C
bed1 <- generateRandomBed(nr = 300)
bed2 <- generateRandomBed(nr = 300)
bed_list <- list(bed1, bed2)

circos.genomicTrack(bed_list, 
                    panel.fun = function(region, value, ...){
                      i = getI(...)
                      circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...)
                    })

# track D
circos.genomicTrack(bed_list, stack = TRUE, 
                    panel.fun = function(region, value, ...){
                      i = getI(...)
                      circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...)
                      circos.lines(x = CELL_META$cell.xlim, 
                                   y = c(i, i), 
                                   lty = 2, 
                                   col = "#00000040")
                    })

# track E
bed <- generateRandomBed(nr = 300, nc = 4)
circos.genomicTrack(bed, panel.fun = function(region, value, ...){
  circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = 1:4, ...)
})

# track F 
bed <- generateRandomBed(nr = 300, nc = 4)
circos.genomicTrack(bed, stack = TRUE, 
                    panel.fun = function(region, value, ...){
                      i = getI(...)
                      circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...)
                      circos.lines(x = CELL_META$cell.xlim, 
                                   y = c(i, i), 
                                   lty = 2, 
                                   col = "#00000040")
                    })

circos.clear()
```


### Lines  
Similar as previous figure, only the first quarter in the circle is visualized.  
```{r}
circos.par("track.height" = 0.08, 'start.degree' = 90, 
           canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), 
           gap.degree = 270, cell.padding = c(0, 4, 0, 4), 
           points.overflow.warning = F)

circos.initializeWithIdeogram(chromosome.index = "chr1", plotType = NULL)

# track A
bed <- generateRandomBed(nr = 500)
circos.genomicTrack(bed, panel.fun = function(region, value, ...){
  circos.genomicLines(region, value, numeric.column = 1)
  circos.text(x = -0.2, y = 0.3, labels = "A", xpd = TRUE)
})


# track B
circos.genomicTrack(bed, panel.fun = function(region, value, ...){
  circos.genomicLines(region, value, area = TRUE)
  circos.text(x = -0.2, y = 0.3, labels = "B", xpd = TRUE)
})

# track C
circos.genomicTrack(bed, panel.fun = function(region, value, ...){
  circos.genomicLines(region, value, type = "h")
  circos.text(x = -0.2, y = 0.5, labels = "C", xpd = TRUE)
})

# track D, input is a list of data frame panel.fun is applied to each data frame iterately.  
bed1 = generateRandomBed(nr = 500)
bed2 = generateRandomBed(nr = 500)
bed_list <- list(bed1, bed2)
circos.genomicTrack(bed_list, 
                    panel.fun = function(region, value, ...){
                      i = getI(...)
                      circos.genomicLines(region, value, col = i, ...)
                      circos.text(x = -0.2, y = 0.3, labels = "D", xpd = TRUE)
                    })

# track E, stack mode 
circos.genomicTrack(bed_list, stack = TRUE, 
                    panel.fun = function(region, value, ...){
                      i = getI(...)
                      circos.genomicLines(region, value, col = i, ...)
                      circos.text(x = -0.2, y = 1.5, labels = "E", xpd = TRUE)
                    })

# track F, data frame with four numeric columns 
bed <- generateRandomBed(nr = 500, nc = 4)
circos.genomicTrack(bed, panel.fun = function(region, value, ...){
  circos.genomicLines(region, value, col = 1:4, ...)
  circos.text(x = -0.2, y = 0.3, labels = "F", xpd = TRUE)
})

# track G, data frame with four numeric columns, in stack mode
bed <- generateRandomBed(nr = 500, nc = 4)
circos.genomicTrack(bed, stack = TRUE, 
                    panel.fun = function(region, value, ...){
                      i = getI(...)
                      circos.genomicLines(region, value, col = i, ...)
                      circos.text(x = -0.2, y = 2.5, labels = "G", xpd = TRUE)
                    })

# track H
bed <- generateRandomBed(nr = 200)
circos.genomicTrack(bed, panel.fun = function(region, value, ...){
  circos.genomicLines(region, value, type = "segment", lwd = 2, 
                      col = rand_color(nrow(region)), ...)
  circos.text(x = -0.2, y = 0.3, labels = "H", xpd = TRUE)
})

circos.clear()
```


`circos.genomicLines()` is implemented by `circos.lines()`, thus, arguments supported in `circos.lines()` can also be in `circos.genomicLines()`.  



### Rectangles  
```{r}
circos.par("track.height" = 0.15, start.degree = 90, 
           canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), 
           gap.degree = 270)

circos.initializeWithIdeogram(chromosome.index = "chr1", plotType = NULL)
col_fun <- colorRamp2(breaks = c(-1, 0, 1), colors = c('green', "black", "red"))

# track A, heatmap with stack mode
bed <- generateRandomBed(nr = 100, nc = 4)
circos.genomicTrack(bed, stack = TRUE, 
                    panel.fun = function(region, value, ...){
                      circos.genomicRect(region, value, col = col_fun(value[[1]]), border = NA, ...)
                    })

# track B, list of data frame under stack mode
bed1 <- generateRandomBed(nr = 100)
bed2 <- generateRandomBed(nr = 100)
bed_list <- list(bed1, bed2)

circos.genomicTrack(bed_list, stack = TRUE, 
                    panel.fun = function(region, value, ...){
                      i = getI(...)
                      circos.genomicRect(region, value, ytop = i + 0.3, 
                                         ybottom = i - 0.3, 
                                         col = col_fun(value[[1]]), ...)
                    })

# track C, list of data frame in normal mode 
circos.genomicTrack(bed_list, ylim = c(0.5, 2.5), 
                    panel.fun = function(region, value, ...){
                      i = getI(...)
                      circos.genomicRect(region, value, 
                                         ytop = i + 0.3, 
                                         ybottom = i - 0.3, 
                                         col = col_fun(value[[1]]), ...)
                    })

# track D 
bed <- generateRandomBed(nr = 200)
circos.genomicTrack(bed, panel.fun = function(region, value, ...){
  circos.genomicRect(region, value, ytop.column = 1, ybottom = 0,
                     col = ifelse(value[[1]] > 0, "red", "green"), ...)
  
  circos.lines(x = CELL_META$cell.xlim, 
               y = c(0, 0), 
               lty = 2, 
               col = "#00000040")
})

circos.clear()
```

# Chapter 11 High-level genomic functions  
## Ideograms  
`circos.initializeWithIdeogram()` initializes the circular plot and adds ideogram track if the cytoband data is available. Actually, the ideograms are drawn by `circos.genomicIdeogram()`.  

`circos.genomicIdeogram()` creates a small track of ideograms and can be used anywhere in the circle. By default it adds ideograms for human genome hg19.  
```{r}
circos.initializeWithIdeogram(plotType = c("labels", "axis"))
circos.track(ylim = c(0, 1))
circos.genomicIdeogram() # put ideogram as the third track
circos.genomicIdeogram(track.height = 0.2)
```

## Heatmaps  
Matrix which corresponds to genomic regions can be visualized as heatmaps. Heatmaps completely fill the track and there are connection lines connecting heatmaps and original positions in the genome. `circos.genomicHeamtap()` draws connection lines and heatmaps as two tracks and combines them as an integrated track.  

Generally, all numeric columns (excluding the first three columns) in the input data frame are used to make the heatmap. Columns can also be specified by `numeric.column` which is either an numeric vector or a character vector. Colors can be specfied as a color matrix or a color mapping function generated by `colorRamp2()`.  

The height of the connection line track and the heatmap track can be set by `connection_height` and `heatmap_height` arguments. Also parameters for the styles of lines and rectangle borders can be adjusted, please check the help page of `circos.genomicHeatmap()`.  

```{r}
circos.initializeWithIdeogram()
bed <- generateRandomBed(nr = 100, nc = 4)
col_fun <- colorRamp2(breaks = c(-1, 0, 1), color = c("green", "black", "red"))
circos.genomicHeatmap(bed, col = col_fun, side = "inside", border = "white")
circos.clear()
```

```{r}
circos.initializeWithIdeogram(plotType = NULL)
circos.genomicHeatmap(bed, col = col_fun, side = "outside", 
                      line_col = as.numeric(factor(bed[[1]])))
circos.genomicIdeogram()
circos.clear()
```

## Labels  
`circos.genomicLabels()` adds text labels for regions that are specified. Positions of labels are automatically adjusted so that they do not overlap to each other.  

Similar as `circos.genomicHeatmap()`, `circos.genomicLabels()` also creates two tracks where one for the connection lines and one for the labels. You can set the height of the labels track to be the maximum width of labels by `labels_height = max(strwidth(labels))`. `padding` argument controls the gap between two neighbouring labels.  
```{r}
circos.initializeWithIdeogram()
bed <- generateRandomBed(nr = 50, fun = function(k) sample(letters, k, replace = TRUE))
bed[1, 4] <- "aaaaa"
circos.genomicLabels(bed, labels.column = 4, side = "inside")
circos.clear()
```

```{r}
circos.initializeWithIdeogram(plotType = NULL)
circos.genomicLabels(bed, labels.column = 4, side = "outside", 
                     col = as.numeric(factor(bed[[1]])), line_col = as.numeric(factor(bed[[1]])))
circos.genomicIdeogram()
circos.clear()
```

## Genomic axes  
The genomic axes are not really high-level graphics, but it is better to also introduce here. For `circos.initializeWithIdeogram()`, by default it draws axes with tick labels properly formatted. The axes are internally implemented by `circos.genomicAxis()` and it can be used to add genomic axes at any track.  
```{r}
circos.initializeWithIdeogram(plotType = NULL)
circos.genomicIdeogram()
# still work on the ideogram track 
circos.track(track.index = get.current.track.index(), panel.fun = function(x, y){
  circos.genomicAxis(h = "top")
})

circos.track(ylim = c(0, 1), track.height = 0.1)
circos.track(track.index = get.current.track.index(), panel.fun = function(x, y){
  circos.genomicAxis(h  ="bottom", direction = "inside")
})

circos.clear()
```


## Genomic density and Rainfall plot  
Rainfall plots are used to visualize the distribution of genomic regions in the genome. Rainfall plots are particularly useful to identify clusters of regions. In the rainfall plot, each dot represents a region. The x-axis corresponds to the genomic coordinate, and the y-axis corresponds to the minimal distance (log10 transformed) of the region to its two neighbouring regions. A cluster of regions will appear as a “rainfall” in the plot.  

`circos.genomicRainfall()` calculates neighbouring distance for each region and draw as points on the plot. Since `circos.genomicRainfall()` generates data on y-direction (`log10(distance)`), it is actually a high-level function which creates a new track.  

The input data can be a single data frame or a list of data frames.  
```{r,eval=FALSE}
circos.genomicRainfall(bed)
circos.genomicRainfall(bed_list, col = c("red", "green"))
```

However, if the amount of regions in a cluster is high, dots will overlap, and direct assessment of the number and density of regions in the cluster will be impossible. To overcome this limitation, additional tracks are added which visualize the genomic density of regions (defined as the fraction of a genomic window that is covered by genomic regions).  

`circos.genomicDensity()` calculates how much a genomic window is covered by regions in `bed`. It is also a high-level function and creates a new track.  

The input data can be a single data frame or a list of data frames.  
```{r, eval=FALSE}
circos.genomicDensity(bed)
circos.genomicDensity(bed, baseline = 0)
circos.genomicDensity(bed, window.size = 1e6)
circos.genomicDensity(bedlist, col = c("#FF000080", "#0000FF80"))
```

Following example makes a rainfall plot for differentially methylated regions (DMR) and their genomic densities. In the plot, red corresponds to hyper-methylated DMRs (gain of methylation) and blue corresponds to hypo-methylated DMRs (loss of methylation). You may see how the combination of rainfall track and genomic density track helps to get a more precise inference of the distribution of DMRs on genome.  

```{r}
load(system.file(package = "circlize", "extdata", "DMR.RData"))
circos.initializeWithIdeogram(chromosome.index = paste0("chr", 1:22))

bed_list <- list(DMR_hyper, DMR_hypo)
circos.genomicRainfall(bed_list, pch = 16, cex = 0.4, col = c("#FF000080", "#0000FF80"))
circos.genomicDensity(DMR_hyper, col = c("#FF000080"), track.height = 0.1)
circos.genomicDensity(DMR_hypo, col = c("#0000FF80"), track.height = 0.1)

circos.clear()
```

Internally, rainfallTransform() and genomicDensity() are used to the neighbrouing distance and the genomic density values.  
```{r}
rainfallTransform(DMR_hyper) %>% head()
```

```{r}
genomicDensity(DMR_hyper, window.size = 1e6) %>% head()
```


# Chapter 12 Nested zooming  
## Basic idea  
In Section 6.1 we introduced how to zoom sectors to the same circle in the same track. This works fine if there are only a few regions that need to be zoomed. However, when the regions that need to be zoomed is too many, the method will not work efficiently. In this chapter, we introduce another zooming method which puts zoomed regions in a different circular plot.  

To illustrate the basic idea, we first generate a random data set.  
```{r}
set.seed(123)
df <- data.frame(
  cate = sample(letters[1:8], 400, replace = T), 
  x = runif(400), 
  y = runif(400), 
  stringsAsFactors = F
)

df <- df[order(df[[1]], df[[2]]), ]
rownames(df) <- NULL

df$interval_x <- as.character(cut(df$x, c(0, 0.2, 0.4, 0.6, 0.8, 1.0)))
df$name <- paste(df$cate, df$interval_x, sep = ":")
df$start <- as.numeric(gsub("^\\((\\d(\\.\\d)?).*(\\d(\\.\\d)?)]", "\\1", df$interval_x))
df$end = as.numeric(gsub("^\\((\\d(\\.\\d)?),(\\d(\\.\\d)?)]$", "\\3", df$interval_x))
nm <- sample(unique(df$name), 20)
df2 <- df[df$name %in% nm, ]

correspondance <- unique(df2[, c("cate", "start", "end", "name", "start", "end")])
zoom_sector <- unique(df2[, c("name", "start", "end", "cate")])
zoom_data <- df2[, c("name", "x", "y")]

data <- df[, 1:3]
sector <- data.frame(cate = letters[1:8], start = 0, end = 1, stringsAsFactors = F)
sector_col <- structure(rand_color(8, transparency = 0.5), names = letters[1:8])
```


```{r}
f1 <- function(){
  circos.par(gap.degree = 10)
  circos.initialize(sector[, 1], xlim = sector[, 2:3])
  circos.track(factors = data[[1]], x = data[[2]], y = data[[3]], ylim = c(0, 1), 
               panel.fun = function(x, y){
                 circos.points(x, y, pch = 16, cex = 0.5, col = "red")
               })
}

f2 <- function(){
  circos.par(gap.degree = 2, cell.padding = c(0, 0, 0, 0))
  circos.initialize(factors = zoom_sector[[1]], xlim = as.matrix(zoom_sector[, 2:3]))
  circos.track(factors = zoom_data[[1]], x = zoom_data[[2]], y = zoom_data[[3]], 
               panel.fun = function(x, y){
                 circos.points(x, y, pch = 16, cex = 0.5)
               })
}
```

`f1` is the code for generating the original plot and `f2` is the code for generating the zoomed plot. They can be executed independently.   

To combine the two plots, simply put `f1`, `f2` and `corresponance` to `circos.nested()`.  

```{r}
circos.nested(f1, f2, correspondance)
```

In the plot, the zoomed circle is put inside the original circle and the start degree for the second plot is automatically adjusted.  

Zoomed circle can also be put outside by swtiching `f1()` and `f2()`. Actually, for `circos.nested()`, It doesn’t care which one is zoomed or not, they are just two circular plots and a correspondance.  

```{r}
circos.nested(f2, f1, correspondance[, c(4:6, 1:3)])
```


There are some points that need to be noted while doing nested zoomings:  

1. It can only be applied to the full circle.  
2. If `canvas.xlim` and `canvas.ylim` are adjusted in the first plot, same value should be set to the second plot.  
3. By default the start degree of the second plot is automatically adjusted to make the difference between the original positions and zoomed sectors to a minimal. However, users can also manually adjusted the start degree for the second plot by setting `circos.par("start.degree" = ...)` and `adjust_start_degree` must be set to TRUE in `circos.nested()`.  
4. Since the function needs to know some information for the two circular plots, do not put `circos.clear()` at the end of each plot. They will be added internally.  

`f1` and `f2` are just normal code fro implementing circular plot. There is no problem to make it more complex.  

```{r}
sector_col <- structure(rand_color(n = 8, transparency = 0.5), names = letters[1:8])

f1 = function() {
    circos.par(gap.degree = 10)
    circos.initialize(sector[, 1], xlim = sector[, 2:3])
    circos.track(data[[1]], x = data[[2]], y = data[[3]], ylim = c(0, 1), 
        panel.fun = function(x, y) {
            l = correspondance[[1]] == CELL_META$sector.index
            if(sum(l)) {
                for(i in which(l)) {
                    circos.rect(correspondance[i, 2], CELL_META$cell.ylim[1],
                                correspondance[i, 3], CELL_META$cell.ylim[2],
                                col = sector_col[CELL_META$sector.index],
                                border = sector_col[CELL_META$sector.index])
                }
            }
            circos.points(x, y, pch = 16, cex = 0.5)
            circos.text(CELL_META$xcenter, CELL_META$ylim[2] + uy(2, "mm"), 
                CELL_META$sector.index, niceFacing = TRUE, adj = c(0.5, 0))
    })
}

f2 = function() {
    circos.par(gap.degree = 2, cell.padding = c(0, 0, 0, 0))
    circos.initialize(zoom_sector[[1]], xlim = as.matrix(zoom_sector[, 2:3]))
    circos.track(zoom_data[[1]], x = zoom_data[[2]], y = zoom_data[[3]], 
        panel.fun = function(x, y) {
            circos.points(x, y, pch = 16, cex = 0.5)
        }, bg.col = sector_col[zoom_sector$cate],
        track.margin = c(0, 0))
}

circos.nested(f1, f2, correspondance, connection_col = sector_col[correspondance[[1]]])
```

## Visualization of DMRs from tagmentation-based WGBS  
Tagmentation-based whole-genome bisulfite sequencing (T-WGBS) is a technology which can examine only a minor fraction of methylome of interest. In this section, we demonstrate how to visualize DMRs which are detected from T-WGBS data in a circular plot by circlize package.  

In the example data loaded, `tagments` contains regions which are sequenced, `DMR1` contains DMRs for one patient detectd in tagment regions. Correspondance between tagment regions and original genome is stored in `correspondance`.  

```{r}
load(system.file(package = "circlize", "extdata", "tagments_WGBS_DMR.RData"))
head(tagments)
```

```{r}
head(DMR1)
```

```{r}
head(correspondance)
```

In following code, `f1()` only makes a circular plot with whole genome and `f2()` makes circular plot for the tagment regions.  
```{r}
chr_bg_color <- rand_color(n = 22, transparency = 0.8)
names(chr_bg_color) <- paste0("chr", 1:22)

f1 <- function(){
  circos.par(gap.after = 2, start.degree = 90)
  circos.initializeWithIdeogram(chromosome.index = paste0("chr", 1:22),
                                plotType = c("ideogram", "labels"), 
                                ideogram.height = 0.03)
}

f2 <- function(){
  circos.par(cell.padding = c(0, 0, 0, 0), gap.after = c(rep(1, nrow(tagments) - 1), 10))
  circos.genomicInitialize(data = tagments, plotType = NULL)
  circos.genomicTrack(DMR1, ylim = c(-0.6, 0.6), 
                      panel.fun = function(region, value, ...){
                        for(h in seq(-0.6, 0.6, by = 0.2)){
                          circos.lines(x = CELL_META$cell.xlim, 
                                       y = c(0, 0), 
                                       lty = 3, 
                                       col = "#AAAAAA")}
                        
                        circos.lines(x = CELL_META$cell.xlim, 
                                     y = c(0, 0), 
                                     lty = 3, 
                                     col = "#888888")
                          
                        circos.genomicPoints(region, value, 
                                               col = ifelse(value[[1]] > 0, "#E41A1C", "#377EB8"), 
                                               pch = 16, 
                                             cex = 0.5)
                      }, bg.col = chr_bg_color[tagments$chr], track.margin = c(0.02, 0))
  
  circos.yaxis(side = "left", at = seq(-0.6, 0.6, by = 0.3), 
               sector.index = get.all.sector.index()[1], labels.cex = 0.4)
  
  circos.track(ylim = c(0, 1), track.height = uh(2, "mm"), 
               bg.col = add_transparency(chr_bg_color[tagments$chr], 0))
}
```

```{r}
circos.nested(f1, f2, correspondance, connection_col = chr_bg_color[correspondance[[1]]])
```


# Chapter 13 The `chordDiagram()` function  
One unique feature of circular layout is the circular visualization of relations between objects by links. See examples in [this site](http://circos.ca/intro/tabular_visualization/). The name of such plot is called `Chord diagram`. In **circlize**, it is easy to plot Chord diagram in a straightforward or in a highly customized way.  

There are two data formats that represent relations, either adjacency matrix or adjacency list. In adjacency matrix, value in i^th^ row and j^th^ column represents the relation from object in the i^th^ row and the object in the j^th^ column where the absolute value measures the strength of the relation. In adjacency list, relations are represented as a three-column data frame in which relations come from the first column and to the second column, and the third column represents the strength of the relation.  

Following code shows an example of an adjacency matrix.  
```{r}
mat <- matrix(1:9, 3)
rownames(mat) <- letters[1:3]
colnames(mat) <- LETTERS[1:3]
mat
```

And the code in below is an example of a adjacency list.  
```{r}
df <- data.frame(from = letters[1:3], to = LETTERS[1:3], value = 1:3)
df
```

Actually, it is not difficult to convert between these two formats. There are also R packages and functions do the conversion such as in **reshape2** package, `melt()` converts a matrix to a data frame and `dcast()` converts the data frame back to the matrix.  

Chord diagram shows the information of the relation from several levels.  

1. the links are straightforward to show the relations between objects.  
2. width of links are proportional to the strength of the relation which is more illustrative than other graphic mappings.  
3. colors of links can be another graphic mapping for relations.  
4. width of sectors represents total strength for an object which connects to other objects or is connected from other objects.  

In **circlize** package, there is a chordDiagram() function that supports both adjacency matrix and adjacency list. For different formats of input, the corresponding format of graphic parameters will be different either. E.g. when the input is a matrix, since information of the links in the Chord diagram is stored in the matrix, corresponding graphics for the links sometimes should also be specified as a matrix, while if the input is a data frame, the graphic parameters for links only need to be specified as an additional column to the data frame. However, in many cases, adjacency matrix is directly generated from upstream analysis and converting it into a adjacency list does not make sense, e.g. converting a correlation matrix to a adjacency list is obviously a bad idea. Thus, in this chapter, we will show usage for both adjacency matrix and list.  

Since the usage for the two types of inputs are highly similar, in this chapter, we mainly show figures generated from matrix, but still keep the code which uses adjacency list runable.  

## Basic usage  
First let's generate a random matrix and the corresponding adjacency list.  
```{r}
set.seed(999)
mat <- matrix(sample(18, 18), 3, 6)
rownames(mat) <- paste0("S", 1:3)
colnames(mat) <- paste0("E", 1:6)
mat
```

```{r}
df <- data.frame(from = rep(rownames(mat), times = ncol(mat)), 
                 to = rep(colnames(mat), times = ncol(mat)), 
                 value = as.vector(mat), 
                 stringsAsFactors = F)
df
```

```{r}
chordDiagram(mat)

# or 
chordDiagram(df)
```

The default Chord Diagram consists of a track of labels, a track of grids (or you call it lines) with axes, and links. Sectors which correspond to rows in the matrix locate at the bottom half of the circle. The order of sectors is the order of `union(rownames(mat), colnames(mat))` or `union(df[[1]], df[[2]])` if input is a data frame. The order of sectors can be controlled by `order` argument (Figure 13.2). Of course, the length of order vector should be same as the number of sectors.  

In following code, `S1`, `S2` and `S3` should better be put together since they belong to a same group, which is same for `E*` sectors. Of course, you can give a order which mix `S*` and `E*`, but it is not recommended because it is bad for reading the plot.  

```{r}
chordDiagram(mat, order = c("S2", "S1", "S3", "E4", "E1", "E5", "E2", "E6", "E3"))
circos.clear()
```

Under default settings, the grid colors which represent sectors are randomly generated, and the link colors are same as grid colors which correspond to rows (or the first column if the input is an adjacency list) but with 50% transparency.  


## Adjust by `circos.par()`  
Since Chord Diagram is implemented by basic circlize functions, like normal circular plot, the layout can be customized by `circos.par()`.  

The gaps between sectors can be set by `circos.par(gap.after = ...)` (Figure 13.3). It is useful when you want to distinguish sectors between rows and columns. Please note since you change default graphical settings, you need to use `circos.clear()` in the end of the plot to reset it.  

```{r}
circos.par(gap.after = c(rep(5, nrow(mat) - 1), 15, rep(5, ncol(mat) - 1), 15))
chordDiagram(mat)
```

if the input is a data frame  
```{r}
circos.par(gap.after = c(rep(5, length(unique(df[[1]])) - 1), 15, 
                         rep(5, length(unique(df[[2]])) - 1), 15))

chordDiagram(df)
circos.clear()
```

To make it simple, users can directly set `big.gap` in `chordDiagram()` (Figure 13.4). The value of `big.gap` corresponds to the gap between row sectors and column sectors (or first-column sectors and second-column sectors in the input is a data frame). Internally a proper `gap.after` is assigned to `circos.par()`. Note it will only work when there is no overlap between row sectors and column sectors.  

```{r}
chordDiagram(mat, big.gap = 10)
circos.clear()
```

small.gap argument controls the gap between sectors corresponding to either matrix rows or columns. The default value is 1 degree and normally you don’t need to set it.  

For Chord diagrams of which row sectors and column sectors have no overlap, by default the big.gap is set to 10 degrees unless you set `circos.par(gap.after = ...)` beforehand.  

Similar to a normal circular plot, the first sector (which is the first row in the adjacency matrix or the first row in the adjacency list) starts from right center of the circle and sectors are arranged clock-wisely. The start degree for the first sector can be set by `circos.par(start.degree = ...)` and the direction can be set by `circos.par(clock.wise = ...)`.  

```{r}
circos.par(start.degree = 90, clock.wise = F)
chordDiagram(mat)

circos.clear()
```


## Colors  
### Set grid colors  
Grids have different colors to represent different sectors. Generally, sectors are divided into two groups. One contains sectors defined in rows of the matrix or the first column in the data frame, and the other contains sectors defined in columns of the matrix or the second column in the data frame. Thus, links connect objects in the two groups. By default, link colors are same as the color for the corresponding sectors in the first group.  

Changing colors of grids may change the colors of links as well. Colors for grids can be set through `grid.col` argument. Values of `grid.col` better be a named vector of which names correspond to sector names. If it is has no name index, the order of `grid.col` is assumed to have the same order as sectors.  

```{r}
par(mfrow = c(1, 2))
grid.col <- c(S1 = "red", S2 = "green", S3 = "blue", 
              E1 = "grey", E2 = "grey", E3 = "grey", E4 = "grey", E5 = "grey", E6 = "grey")

chordDiagram(mat, grid.col = grid.col)
chordDiagram(t(mat), grid.col = grid.col)
```

### Set link colors  
Transparency of link colors can be set by `transparency` argument (Figure 13.7). The value should between 0 to 1 in which 0 means no transparency and 1 means full transparency. Default transparency is 0.5.  

```{r}
chordDiagram(mat, grid.col = grid.col, transparency = 0)
circos.clear()
```

For adjacecy matrix, colors for links can be customized by providing a matrix of colors. In the following example, we use `rand_color()` to generate a random color matrix. Note since `col_mat` already contains transparency, `transparency` will be ignored if it is set.  

```{r}
col_mat <- rand_color(n = length(mat), transparency = 0.5)
dim(col_mat) = dim(mat)
chordDiagram(mat, grid.col = grid.col, col = col_mat)
```


When the strength of the relation (e.g. correlations) represents as continuous values, `col` can also be specified as a self-defined color mapping function. `chordDiagram()` accepts a color mapping generated by `colorRamp2()`.  

```{r}
col_fun <- colorRamp2(breaks = range(mat), colors = c("#FFEEEE", "#FF0000"), transparency = 0.5)
chordDiagram(mat, grid.col = grid.col, col = col_fun)
```

The color mapping function also works for adjacency list, but it will be applied to the third column in the data frame, so you need to make sure the third column has the proper values.  

```{r}
chordDiagram(df, grid.col = grid.col, col = col_fun)
```

When the input is a matrix, sometimes you don’t need to generate the whole color matrix. You can just provide colors which correspond to rows or columns so that links from a same row/column will have the same color. Here note values of colors can be set as numbers, color names or hex code, same as in the base R graphics.  

```{r}
par(mfrow = c(1, 2))
chordDiagram(mat, grid.col = grid.col, row.col = 1:3)
chordDiagram(mat, grid.col = grid.col, column.col = 1:6)
```

`row.col` and `column.col` is specifically designed for matrix. There is no similar settings for ajacency list.  

To emphasize again, transparency of links can be included in `col`, `row.col` or `column.col`, if transparency is already set there, `transparency` argument will be ignored.  

## Link border  
`link.lwd`, `link.lty` and `link.border` control the line width, the line style and the color of the link border. All these three parameters can be set either a single scalar or a matrix if the input is adjacency matrix.  

If it is set as a single scalar, it means all links share the same style.  
```{r}
chordDiagram(mat, grid.col = grid.col, link.lwd = 2, link.lty = 2, link.border = "red")
```

If it is set as a matrix, it should have same dimension as mat.  
```{r}
lwd_mat <- matrix(data = 1, nrow = nrow(mat), ncol = ncol(mat))
lwd_mat[mat > 12] <- 2
border_mat <- matrix(data = NA, nrow = nrow(mat), ncol = ncol(mat))
border_mat[mat > 12] <- "red"
chordDiagram(mat, grid.col = grid.col, link.lwd = lwd_mat, link.border = border_mat)
```

The matrix is not necessary to have same dimensions as in `mat`. It can also be a sub matrix. For rows or columns of which the corresponding values are not specified in the matrix, default values are filled in. It must have row names and column names so that the settings can be mapped to the correct links.  
```{r}
border_mat2 <- matrix(data = "black", nrow = 1, ncol = ncol(mat))
rownames(border_mat2) <- rownames(mat)[2]
colnames(border_mat2) <- colnames(mat)
chordDiagram(mat, grid.col = grid.col, link.lwd = 2, link.border = border_mat2)
```

To be more convenient, graphic parameters can be set as a three-column data frame in which the first two columns correspond to row names and column names in the matrix, and the third column corresponds to the graphic parameters.  
```{r}
lty_df <- data.frame(c("S1", "S2", "S3"), c("E5", "E6", "E4"), c(1, 2, 3))
lwd_df <- data.frame(c("S1", "S2", "S3"), c("E5", "E6", "E4"), c(2, 2, 2))
border_df = data.frame(c("S1", "S2", "S3"), c("E5", "E6", "E4"), c(1, 1, 1))

chordDiagram(mat, grid.col = grid.col, 
             link.lty = lty_df, 
             link.lwd = lwd_df, 
             link.border = border_df)
```

It is much easier if the input is a data frame, you only need to set graphic settings as a vector.  

```{r}
chordDiagram(df, grid.col = grid.col, link.lty = sample(1:3, nrow(df), replace = T), 
             link.lwd = runif(nrow(df) * 2), link.border = sample(0:1, nrow(df), replace = T))
```

## Highlight links  
Sometimes we want to highlight some links to emphasize the importance of such relations. Highlighting by different border styles are introduced in Section 13.4 and here we focus on highlighting by colors.

THere are two ways to highlight links, one is to set different transparency to different links and the other is to only draw links that needs to be highlighted. Based on this rule and ways to assign colors to links (introduced in Section 13.3.2), we can highlight links which come from a same sector by assigning colors with different transparency by `row.col` argument.  

```{r}
chordDiagram(mat, grid.col = grid.col, row.col = c("#FF000080", "#00FF0010", "#0000FF10"))
```

We can also highlight links with values larger than a cutoff. There are at least three ways to do it. First, construct a color matrix and set links with small values to full transparency.  

Since link colors can be specified as a matrix, we can set the transparency of those links to a high value or even set to full transparency.  

In following example, links with value less than 12 is set to `#00000000`.  

```{r}
col_mat <- rand_color(n = length(mat), transparency = 0.5)
dim(col_mat) <- dim(mat)
col_mat[mat < 12] <- "#00000000"
chordDiagram(mat, grid.col = grid.col, col = col_mat)
```

```{r}
col_fun = function(x) ifelse(x < 15, "#00000000", "#FF000080")
chordDiagram(mat, grid.col = grid.col, col = col_fun)
```

Highlighting links is relatively simple for adjacency list that you only need to construct a vector of colors according to what links you want to highlight.  

```{r}
col <- rand_color(nrow(df))
col[df[[3]] < 13] <- "#00000000"
chordDiagram(df, grid.col = grid.col, col = col)
```

The `link.visible` argument is recently introduced to **circlize** package which may provide a simple to control the visibility of links. The value can be set as an logical matrix for adjacency matrix or a logical vector for adjacency list.  

```{r}
col <- rand_color(nrow(df))
chordDiagram(df, grid.col = grid.col, link.visible = df[[3]] > 13)
```

## Orders of links  
### Orders of positions on sectors  
Orders of links on every sector are adjusted automatically to make them look nice. But sometimes sorting links according to the width on the sector is useful for detecting potential features. `link.sort` and `link.decreasing` can be set to control the order of positioning links on sectors.  

```{r}
par(mfrow = c(1, 2))
chordDiagram(mat, grid.col = grid.col, link.sort = TRUE, link.decreasing = T)
title("link.sort = TRUE, link.decreasing = TRUE", cex = 0.6)
chordDiagram(mat, grid.col = grid.col, link.sort = TRUE, link.decreasing = F)
title("link.sort = TRUE, link.decreasing = F", cex = 0.6)
```

### Order of adding links  
The default order of adding links to the plot is based on their order in the matrix or in the data frame. Normally, transparency should be set to the link colors so that they will not overlap to each other. In most cases, this looks fine, but sometimes, it improves the visualization to put wide links more forward and to put small links more backward in the plot. This can be set by `link.rank` argument which defines the order of adding links. Larger value means the corresponding link is added later.  

```{r}
par(mfrow = c(1, 2))
chordDiagram(mat, grid.col = grid.col, transparency = 0)
chordDiagram(mat, grid.col = grid.col, transparency = 0, link.rank = rank(mat))
```

Similar code if the input is a data frame.  
```{r}
chordDiagram(df, grid.col = grid.col, transparency = 0, link.rank = rank(df[[3]]))
```

## Self-links  
How to set self links dependends on wheter the information needs to be duplicated. The `self.link` argument can be set to `1` or `2` for the two different scenarios.  
```{r}
par(mfrow = c(1, 2))
df2 <- data.frame(start = c("a", "b", "c", "a"), 
                  end = c("a", "a", "b", "c"))
chordDiagram(df2, grid.col = 1:3, self.link = 1)
title("self.link = 1")

chordDiagram(df2, grid.col = 1:3, self.link = 2)
title("self.link = 2")
```

## Symmetric matrix  
When the matrix is symmetric, by setting `symmetric = TRUE`, only lower triangular matrix without the diagonal will be used.  
```{r}
par(mfrow = c(1, 2))
mat3 <- matrix(rnorm(25), 5)
colnames(mat3) <- letters[1:5]
cor_mat <- cor(mat3)
col_fun <- colorRamp2(breaks = c(-1, 0, 1), colors = c("green", "white", "red"))
chordDiagram(cor_mat, grid.col = 1:5, symmetric = TRUE, col = col_fun)
title("symmetric = TRUE")
chordDiagram(cor_mat, grid.col = 1:5, col = col_fun)
title("symmetric = FALSE")
```

## Directional relations  
In some cases, when the input is a matrix, rows and columns represent directions, or when the input is a data frame, the first column and second column represent directions. Argument `directional` is used to illustrate such direction on the plot. `directional` with value `1` means the direction is from rows to columns (or from the first column to the second column for the adjacency list) while `-1` means the direction is from columns to rows (or from the second column to the first column for the adjacency list). A value of `2` means bi-directional.  

By default, the two ends of links have unequal height to represent the directions. The position of starting end of the link is shorter than the other end to give users the feeling that the link is moving out. If this is not what your correct feeling, you can set `diffHeight` to a negative value.  
```{r}
par(mfrow = c(1, 3))
chordDiagram(mat, grid.col = grid.col, directional = 1)
chordDiagram(mat, grid.col = grid.col, directional = 1, diffHeight = uh(5, "mm"))
chordDiagram(mat, grid.col = grid.col, directional = -1)
```

Row names and column names in mat can also overlap. In this case, showing direction of the link is important to distinguish them.  
```{r}
mat2 <- matrix(sample(100, 35), nrow = 5)
rownames(mat2) <- letters[1:5]
colnames(mat2) <- letters[1:7]
mat2
```

```{r}
chordDiagram(mat2, grid.col = 1:7, directional = 1, row.col = 1:5)
```

If you do not need self-link for which two ends of a link are in a same sector, just set corresponding values to 0 in the matrix.  
```{r}
mat3 = mat2
for(cn in intersect(rownames(mat3), colnames(mat3))) {
    mat3[cn, cn] = 0
}
mat3
```

```{r}
chordDiagram(mat3, grid.col = 1:7, directional = 1, row.col = 1:5)
```

Links can have arrows to represent directions. When `direction.type` is set to `arrows`, Arrows are added at the center of links. Similar as other graphics parameters for links, the parameters for drawing arrows such as arrow color and line type can either be a scalar, a matrix, or a three-column data frame.   

If `link.arr.col` is set as a data frame, only links specified in the data frame will have arrows. Pleast note this is the only way to draw arrows to subset of links.  

```{r}
arr.col <- data.frame(c("S1", "S2", "S3"), c("E5", "E6", "E4"), 
                      c("black", "black", "black"))

chordDiagram(mat, grid.col = grid.col, 
             directional = 1, 
             direction.type = "arrows", 
             link.arr.col = arr.col, 
             link.arr.length = 0.2, 
             link.rank = rank(mat))
```

```{r}
chordDiagram(mat, grid.col = grid.col, directional = 1, 
    direction.type = c("diffHeight", "arrows"),
    link.arr.col = arr.col, link.arr.length = 0.2)
```

There is another arrow type: `big.arrow` which is efficient to visualize arrows when there are too many links.  
```{r}
matx <- matrix(rnorm(64), 8)
chordDiagram(matx, directional = 1, 
             direction.type = c("diffHeight", 'arrows'), 
             link.arr.type = "big.arrow")
```

If `diffHeight` is set to negative value, the start ends are longer than the other ends.  
```{r}
chordDiagram(matx, directional = 1, direction.type = c("diffHeight", "arrows"), 
             link.arr.type = "big.arrow", diffHeight = -uh(2, "mm"))
```

It is almost the same to visualize directional Chord diagram form a adjacency list.  
```{r}
chordDiagram(df, directional = 1)
```

## Scaling  
The link on Chord diagram represents the “absolute value” of the relations. Sometimes for a certain sector, we might want to see relatively, how much of it goes to other sectors. In this case, scale argument can be set to TRUE so that on each sector, the value represents the fraction of the interaction going to one other sector.  
```{r}
set.seed(999)
mat <- matrix(sample(18, 18), 3, 6)
rownames(mat) <- paste0("S", 1:3)
colnames(mat) <- paste0("E", 1:6)

grid.col <- c(S1 = "red", S2 = "green", S3 = "blue", 
              E1 = "grey", E2 = "grey", E3 = "grey", E4 = "grey", E5 = "grey", E6 = "grey")
par(mfrow = c(1, 2))
chordDiagram(mat, grid.col = grid.col)
title("Defualt")

chordDiagram(mat, grid.col = grid.col, scale = T)
title("scale = TRUE")
```

After scaling, all sectors have the same size and the data range of each sector are all `c(0, 1)`.  

## Reduce  
If a sector in Chord Diagram is too small, it will be removed from the original matrix, since basically it can be ignored visually from the plot. In the following matrix, the second row and third column contain tiny values.  
```{r}
mat <- matrix(rnorm(36), 6, 6)
rownames(mat) <- paste0("R", 1:6)
colnames(mat) <- paste0("C", 1:6)
mat[2, ] <- 1e-10
mat[3, ] <- 1e-10
```

In the Chord Diagram, categories corresponding to the second row and the third column will be removed.  
```{r}
chordDiagram(mat)
circos.info()
```

The `reduce` argument controls the size of sectors to be removed. The value is a percent of the size of a sector to the total size of all sectors.  

You can also explictly remove sectors by assigning corresponding values to 0.  
```{r}
mat[2, ] = 0
mat[3, ] = 0
```

All parameters for sectors such as colors or gaps between sectors are also reduced accordingly by the function.  


## Input as a data frame  
As mentioned before, both matrix and data frame can be used to represent relations between two sets of features. In previous examples, we mainly demonstrate the use of `chordDiagram()` with matrix as input. Also we show the code with data frame as input for each functionality. Here we will go through these functionality again with data frames and we also show some unique features which is only usable for data frames.  

When the input is a data frame, number of rows in the data frame corresponds to the number of links on the Chord diagram. Many arguments can be set as a vector which have the same length as the number of rows of the input data frame.  
They are:  

+ `transparency`  
+ `col`. Note, `col` can be also a color mapping function generated from `colorRamp2()`.  
+ `link.border`  
+ `link.lwd`  
+ `link.lty`  
+ `link.arr.length`  
+ `link.arr.width`  
+ `link.arr.type`  
+ `link.arr.lty`  
+ `link.arr.col`  
+ `link.arr.visible`  
+ `link.rank`  


### Multiple links  
If the input is a matrix, there can only be one link from sector A to B, but for the data frame, there can be mulitple links for a same pair of sectors. In following example, each pair of sectors have two links, one for positive value and the other for negative value.  

```{r}
df <- expand.grid(letters[1:3], LETTERS[1:4])
df1 <- df
df1$value <- sample(10, nrow(df), replace = TRUE)

df2 <- df
df2$value <- -sample(10, nrow(df), replace = TRUE)
df <- rbind(df1, df2)
grid.col <- structure(1:7, names = c(letters[1:3], LETTERS[1:4]))
chordDiagram(df, col = ifelse(df$value > 0, "red", "green"), grid.col = grid.col)
```

This functionality is useful when you want to visualize as two Chord diagrams, one for positive values and one for negative values, but still correspond the size of sector to the sum of both positive and negative values.  

```{r}
par(mfrow = c(1, 2))
chordDiagram(df, col = "red", link.visible = df$value > 0, grid.col = grid.col)
chordDiagram(df, col = "green", link.visible = df$value < 0, grid.col = grid.col)
```


### Unequal width of the link ends  
Almost all of the Chord diagrams shown in this chapter, the width of the two ends of a link is always the same. This means same amount of information comes from one sector and goes to the other sector. However, for some cases, this is not always true. For example, when do scaling on sectors, the link actually has unequal width of the two ends.  

Since the two ends have different width, now the data frame needs two numeric columns which correspond to the two ends of the links.  

```{r}
df <- expand.grid(letters[1:3], LETTERS[1:4])
df$value <- 1
df$value2 <- 3 # the names of the two colums do not matter
par(mfrow = c(1, 2))
chordDiagram(df[, 1:3], grid.col = grid.col)
title("one column of values")

chordDiagram(df[, 1:4], grid.col = grid.col) # using two value-columns
title("two columns of values")
```

# Chapter 14 Advanced usage of `chordDiagram()`  
## Organization of tracks  
By default, chordDiagram() creates two tracks, one track for labels and one track for grids with axes.  
```{r}
chordDiagram(mat)
circos.info()
```

These two tracks can be controlled by `annotationTrack` argument. Available values for this argument are `grid`, `name` and `axis`. The height of annotation tracks can be set by `annotationTrackHeight` which is the percentage to the radius of unit circle and can be set by `uh()` function with an absolute unit. Axes are only added if `grid` is set in `annotationTrack`.  

```{r}
par(mfrow = c(1, 3))
chordDiagram(mat, grid.col = grid.col, annotationTrack = c("grid"))
chordDiagram(mat, grid.col = grid.col, annotationTrack = c("name", "grid"), annotationTrackHeight = c(0.03, 0.01))
chordDiagram(mat, grid.col = grid.col, annotationTrack = NULL)
```

**Several empty tracks can be allocated before Chord diagram is drawn. Then self-defined graphics can be added to these empty tracks afterwards**. The number of pre-allocated tracks can be set through `preAllocateTracks`.  

```{r}
chordDiagram(mat, preAllocateTracks = 2)
```

```{r}
circos.info()
```

The default settings for pre-allocated tracks are:  
```{r}
list(ylim = c(0, 1), 
     track.height = circos.par("track.height"), 
     bg.col = NA, 
     bg.border = NA, 
     bg.lty = par("lty"), 
     bg.lwd = par("lwd"))
```

The default settings for pre-allocated tracks can be overwritten by specifying `preAllocateTracks` as a list.  
```{r}
chordDiagram(mat, annotationTrack = NULL, 
             preAllocateTracks = list(track.height = 0.3))
```

If more than one tracks need to be pre-allocated, just specify preAllocateTracks as a list which contains settings for each track.  
```{r}
chordDiagram(mat, annotationTrack = NULL, 
             preAllocateTracks = list(list(track.height = 0.1), 
                                      list(bg.border = "black")))
```

By default `chordDiagram()` provides poor supports for customization of sector labels and axes, but with `preAllocateTracks` it is rather easy to customize them.  

## Customize sector labels  
In `chordDiagram()`, there is no argument to control the style of sector labels, but this can be done by first pre-allocating an empty track and customizing the labels in it later. In the following example, one track is firstly allocated and a Chord diagram is added without label track and axes. Later, the first track is updated with adding labels with clockwise facings.  

```{r}
chordDiagram(mat, grid.col = grid.col, annotationTrack = "grid", 
             preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(mat))))))

# we go back to the first track and customize sector labels 
circos.track(track.index = 1, panel.fun = function(x, y){
  circos.text(x = CELL_META$xcenter, y = CELL_META$ylim[1], 
              labels = CELL_META$sector.index, 
              facing = "clockwise", 
              niceFacing = T, adj = c(0, 0.5))
}, bg.border = NA)
```

In the following example, the labels are put on the grids. Please note `circos.text()` and `get.cell.meta.data()` can be used outside `panel.fun` if the sector index and track index are specified explicitly.  
```{r}
chordDiagram(mat, grid.col = grid.col, 
             annotationTrack = c("grid", "axis"), annotationTrackHeight = uh(5, "mm"))

for(si in get.all.sector.index()){
  xlim = get.cell.meta.data(name = "xlim", sector.index = si, track.index = 1)
  ylim = get.cell.meta.data(name = "ylim", sector.index = si, track.index = 1)
  circos.text(x = mean(xlim), y = mean(ylim), labels = si, 
              sector.index = si, 
              track.index = 1, 
              facing = "bending.inside", 
              niceFacing = TRUE, 
              col = "white")
}
```

For the last example in this section, if the width of the sector is less than 20 degree, the labels are added in the radical direction.  
```{r}
set.seed(123)
mat2 <- matrix(rnorm(100), 10)
chordDiagram(mat2, annotationTrack = "grid", 
             preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(mat))))))

circos.track(track.index = 1, panel.fun = function(x, y){
  xlim = get.cell.meta.data(name = "xlim")
  xplot = get.cell.meta.data(name = "xplot")
  ylim = get.cell.meta.data(name = "ylim")
  sector.name = get.cell.meta.data(name = "sector.index")
  
  if(abs(xplot[2] - xplot[1]) < 20){
    circos.text(x = mean(xlim), y = ylim[1], 
                labels = sector.name, 
                facing = "clockwise", 
                niceFacing = TRUE, 
                adj = c(0, 0.5), 
                col = "red")
  }else{
    circos.text(x = mean(xlim), y = ylim[1], 
                labels = sector.name, 
                facing = "inside", 
                niceFacing = TRUE, 
                adj = c(0.5, 0), col = "blue")
  }
}, bg.color = NA)
```

When you set direction of sector labels as radical (`clockwise` or `reverse.clockwise`), if the labels are too long and exceed your figure region, you can either decrease the size of the font or set `canvas.xlim` and `canvas.ylim` parameters in `circos.par()` to wider intervals.  


## Customize sector axes   
Axes are helpfull to correspond to the absolute values of links. By default `chordDiagram()` adds axes on the grid track. But it is easy to customize one with self-defined code.  

In following example code, we draw another type of axes which show relative percent on sectors. We first pre-allocate an empty track by `preAllocateTracks` and come back to this track to add axes later.  

You may see we add the first axes to the top of second track. You can also put them to the bottom of the first track.  
```{r}
# similar as the previous example, but we only plot the grid track
chordDiagram(mat, grid.col = grid.col, annotationTrack = "grid", 
             preAllocateTracks = list(track.height = uh(5, "mm")))

for(si in get.all.sector.index()){
  circos.axis(h = "top", labels.cex = 0.3, sector.index = si, track.index = 2)
}

# the second axis as well as the sector labels are added in this track  
circos.track(track.index = 1, panel.fun = function(x, y){
  xlim = get.cell.meta.data(name = "xlim")
  ylim = get.cell.meta.data(name = "ylim")
  sector.name = get.cell.meta.data(name = "sector.index")
  xplot = get.cell.meta.data(name = "xplot")
  
  circos.lines(x = xlim, y = c(mean(ylim), mean(ylim)), lty = 3)
  by = ifelse(abs(xplot[2] - xplot[1]) > 30, 0.2, 0.5)
  for(p in seq(by, 1, by = by)){
    circos.text(x = p*(xlim[2] - xlim[1]) + xlim[1], 
                y = mean(ylim) + 0.1,
                labels = paste0(p*100, "%"), 
                cex = 0.3, 
                adj = c(0.5, 0), 
                niceFacing = TRUE)
  }
  circos.text(x = mean(xlim), 
              y = 1, 
              labels = sector.name, 
              niceFacing = TRUE, 
              adj = c(0.5, 0))
}, bg.border = NA)

circos.clear()
```

## Put horizontally or vertically symmetric  
In Chord diagram, when there are two groups (which correspond to rows and columns if the input is an adjacency matrix), it is always visually beautiful to rotate the diagram to be symmetric on horizontal direction or vertical direction. See following example  

```{r}
par(mfrow = c(1,2))
circos.par(start.degree = 0)
chordDiagram(mat, grid.col = grid.col, big.gap = 20)
abline(h = 0, lty = 2, col = "#00000080")
circos.clear()

circos.par(start.degree = 90)
chordDiagram(mat, grid.col = grid.col, big.gap = 20)
abline(v = 0, lty = 2, col = "#00000080")
circos.clear()
```

## Compare two Chord disgrams  
Normally, in Chord diagram, values in `mat` are normalized to the summation of the absolute values in the matrix, which means the width for links only represents relative values. Then, when comparing two Chord diagrams, it is necessary that unit width of links in the two plots should be represented in a same scale. This problem can be solved by adding larger gaps to the Chord diagram which has smaller matrix.  

```{r}
par(mfrow = c(1, 2))
mat1 <- matrix(sample(20, 25, replace = TRUE), 5)
chordDiagram(mat1, directional = 1, grid.col = rep(1:5, 2), transparency = 0.5, 
             big.gap = 10, small.gap = 1)

mat2 <- mat1 / 2
gap <- calc_gap(mat1, mat2, big.gap = 10, small.gap = 1)
chordDiagram(mat2, directional = 1, 
             grid.col = rep(1:5, 2), 
             transparency = 0.5, 
             big.gap = gap, 
             small.gap = 1)
```

## Multiple-group Chord diagram  
Generally `chordDiagram()` function visualizes relations between two groups (i.e. from rows to columns if the input is an adjacency matrix or from column 1 to column 2 if the input is an adjacency list), however, for `chordDiagram()`, it actually doesn’t need any grouping information. The visual effect of grouping is just enhanced by setting different gap degrees. In this case, it is easy to make a Chord diagram with more than two groups.  

```{r}
# First let’s generate three matrix which contain pairwise relations from three groups  
options(digits = 2)
mat1 <- matrix(rnorm(25), nrow = 5)
rownames(mat1) <- paste0("A", 1:5)
colnames(mat1) <- paste0("B", 1:5)

mat2 <- matrix(rnorm(25), nrow = 5)
rownames(mat2) <- paste0("A", 1:5)
colnames(mat2) <- paste0("C", 1:5)

mat3 <- matrix(rnorm(25), nrow = 5)
rownames(mat3) <- paste0("B", 1:5)
colnames(mat3) <- paste0("C", 1:5)

# since `chordDiagram()` only accepts one single matrix, here the three matrix are merged into one big matrix 

mat <- matrix(0, nrow = 10, ncol = 10)
rownames(mat) <- c(rownames(mat1), rownames(mat3))
colnames(mat) <- c(colnames(mat1), colnames(mat3))

mat[rownames(mat1), colnames(mat1)] <- mat1
mat[rownames(mat2), colnames(mat2)] <- mat2
mat[rownames(mat3), colnames(mat3)] <- mat3


```

When making the chord diagram, we set larger gaps between groups to identify different groups. Here we manually adjust `gap.after` in `circos.par()`.  

Also we add an additional track in which we add lines to enhance the visual effect of different groups.  
```{r}
circos.par(gap.after = rep(c(rep(1, 4), 8), 3))

chordDiagram(mat, annotationTrack = c("grid", "axis"), 
             preAllocateTracks = list(
               track.height = uh(4, "mm"),
               track.margin = c(uh(4, "mm"), 0)
             ))

circos.track(track.index = 2, panel.fun = function(x, y){
  sector.index = get.cell.meta.data(name = "sector.index")
  xlim = get.cell.meta.data(name = "xlim")
  ylim = get.cell.meta.data(name = "ylim")
  circos.text(x = mean(xlim), y = mean(ylim), 
              labels = sector.index, 
              cex = 0.6, 
              niceFacing = T)
}, bg.border = NA)

highlight.sector(sector.index = rownames(mat1), track.index = 1, col = "red", 
                 text = "A", cex = 0.8, text.col = "gold", niceFacing = TRUE)
highlight.sector(sector.index = colnames(mat1), track.index = 1, col = "blue", 
                 text = "B", cex = 0.8, text.col = "gold", niceFacing = TRUE)
highlight.sector(sector.index = colnames(mat2), track.index = 1, col = "green", 
                 text = "C", cex = 0.8, text.col = "gold", niceFacing = TRUE)

circos.clear()
```

If row names and column names in the big matrix are not grouped, the sector order can be manually adjusted by `order` argument.  

```{r}
circos.par(gap.after = rep(c(rep(1, 4), 8),3))
gc <- rep(brewer.pal(n = 3, name = "Set1"), each = 5)
chordDiagram(mat, order = c(paste0("A", 1:5), paste0("B", 1:5), paste0("C", 1:5)), 
             big.gap = 8, small.gap = 1, grid.col = gc)

circos.clear()
```

It is similar way to construct a multiple-group Chord diagram with data frame as input.  

```{r}
library(reshape2)
df2 <- do.call("rbind", list(melt(mat1), melt(mat2), melt(mat3)))
chordDiagram(df2, order = c(paste0("A", 1:5), paste0("B", 1:5), paste0("C", 1:5)))
circos.clear()
```

















