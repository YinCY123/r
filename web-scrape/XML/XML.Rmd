---
title: "XML"
author: "yincy"
date: "12/27/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Chapter 1 Introduction
```{r}
- `readHTMLTable()`  
- `xmlToList()`  
- `xmlToDataFrame()`  
- `getHTMLLinks()`  
- `xmlParse()`  
- `htmlParse()`  
- `xmlRoot()`  
- `xmlChildren()`  
- `xmlAttrs()`  
- `xmlGetAttr()`  

html <- "/home/yincy/Downloads/XML/List of countries and dependencies by population - Wikipedia.html"
pop <- readHTMLTable(doc = html)
sapply(pop, nrow)
pop <- readHTMLTable(doc = html, which = 1)

xml <- "/home/yincy/git/Data/KEGG/pathways/mouse/mmu00010.xml"
mmu00010 <- xmlParse(file = xml)
mmu00010 %>% xmlRoot() %>% class()
```

```{r}
doc <- xmlParse(file = "exampleData/kiva_lender.xml")
doc %>% class()
doc %>% docName()


lendersNode <- xmlRoot(doc)[["lenders"]]
lendersNode %>% class()
xmlName(lendersNode)
xmlAttrs(lendersNode)
xmlChildren(lendersNode)
xmlValue(lendersNode)
xmlSize(lendersNode)
xmlChildren(lendersNode) %>% length()
lendersNode %>% length()

sapply(xmlChildren(lendersNode), 
       FUN = function(node){xmlValue(node[["occupation"]])})
```

```{r}
lenders <- lendersNode["lender"]
lenders %>% class()
lenders %>% sapply(FUN = function(node){xmlChildren(node) %>% xmlSize}) %>% table
```

```{r}
lender1 <- lenders[[1]]
lender1 %>% names() # the names of the children nodes
lender1 %>% xmlName() # the root node name
```

```{r}
doc <- xmlParse(file = "exampleData/kiva_lender.xml")

lendersNode <- xmlRoot(doc)[["lenders"]]
lendersNode %>% class()
lendersNode %>% xmlSize()
lendersNode[[1]]
```


# Predicate
The syntax of the predicate  
```
[logical-condition]
```

These conditions can be unary or binary operations.  

```
# unary
Cube[@currency] # Cube contain a currency attribute
Cube[not(@currency)]


# binary
Cube[@urrency = "USD"] 
Cube[@rate > 25]
```
In the case of comparing the rate, XPath coerces the value of the attribute from a string to a number for us. There are `number()` functions in XPath to do this explicitly.  

## Boolean operation in the predicate
- `and`  
- `or`  
- `not()`  
- `true()`  
- `false()`  


## number functions in predicate
- `number()`  
- `floor()`  
- `ceiling()`  
- `round()`  


## XPath Functions

|**Function**|**Input**|**Return Value**|
|:--|:--|:--|
|`last()`|node|Number of elements in the context node-set.|
|`position()`|node|Position of the context node within the node-set.|
|`count()`|node|Number of elements in the node-set.|
|`id()`|node|Element with id matching the input string.|
|`name()`|node|Name of the first node in the node-set.|
|`namespace-uri()`|node|Namespace of the context node or the first node in the node-set.|
|`concat()`|string|One string that concatenates the strings provided as input arguments.|
|`starts-with()`|string|true if the first string passed to the function begins with the second string. For example, starts-with(@fileref, ’Images/’)|
|`contains()`|string|true if the first string contains the second.|
|`substring()`|string|Portion of the string starting at the first value for a length of the second value|
|`substring-after()`|string|Portion of the first string that appears after the second string.|
|`substring-before()`|string|Portion of the first string that appears before the second string.|
|`string-length()`|string|Number of characters in the string.|
|`normalize-space()`|string|String with leading and trailing whitespace stripped and reduced if the second string starts with the first string.|
|`translate()`|string|Original string with the portion of the string starting at the first value for a length of the second value. For example, to change a,c,g and t to A,C,G and T respectively, we use `translate('acgt', 'ACGT', string(.))`.|  


## XPath arithmetic operators
- `+`  
- `-`  
- `*`  
- `/`  
- `mod(%)`  



# Using predicate to filtering nodes
```{r}
doc <- xmlParse("exampleData/kiva_lender.xml")

getNodeSet(doc = doc, 
           path = "//lender[number(./loan_count/text()) > 0 and occupation = 'lawyer']") 

getNodeSet(doc = doc, 
           path = "//lender[./loan_count/text() > 0 and occupation = 'lawyer']")

getNodeSet(doc = doc, 
           path = "//lender[./loan_count/text() > 0 and occupation = 'lawyer'][1]")

getNodeSet(doc = doc, 
           path = "//lender[./loan_count/text() > 0 and occupation = 'lawyer']")

# combine multiple query
query <- "//lender[./loan_count/text() > 0 and occupation = 'lawyer'] | //lender[./loan_count > 200 and occupation = 'Programmer']"

getNodeSet(doc = doc, 
           path = query)
# the nodes will be returned in the document order
```

```{r}
template_id <- getNodeSet(xmlRoot(doc), 
           path = "//lender/image/template_id") %>% 
    xmlValue() 
template_id %>% table(useNA = "ifany")
```

```{r}
doc %>% 
    xmlRoot() %>% 
    getSibling(node = xmlRoot(doc)[["lenders"]][[1]], after = T)
```

The `xmlAncestors()` function walks the chain of parents to the top of the document and returns a list of those ancestor nodes. The first will be the root node.  

```{r}
node1 <- doc %>% xmlRoot() %>% .[[2]] %>% .[[1]]
node1 %>% xmlAncestors() %>% .[[1]] %>% xmlName()
```

```{r}
getSibling(node = node1, after = T)
```

The `xmlParse()` function in R by default returns a tree structure which can be treated conceptually as a list of lists, each node in the tree can be treated as a list of its children. Each node also has a name and attributes.  

```{r}
doc <- xmlParse("exampleData/simple.xml")
root <- xmlRoot(doc)
node1_1 <- root[[1]][[1]]
node1_1 <- root[["b"]][["c"]]
node1_1 %>% xmlParent()
node1_1 %>% getSibling(after = T)
```

The `xmlValue()` function is generic so it works on different types of nodes. For nodes that are mixtures of text content and other nodes, `xmlValue()` returns a character string that concatenates the text content of all the node's descendants.  


```{r}
htmlParse("<ol><li>First<li>Second<li>Third</ol>")
```

```{r}
doc %>% class()
otype(doc)
s3_methods_class("XMLInternalDocument")
```


# XPath
```{r}
doc = htmlParse("http://www.omegahat.net/")
doc %>% class()
listOfNodes <- getNodeSet(doc = doc, 
                          path = "//a[@href]")
urls <- sapply(listOfNodes, 
               FUN = xmlGetAttr, 
               name = "href")

urls %>% head(10)
```

```{r}
xpathSApply(doc = doc, 
            path = "//a[@href]", 
            fun = xmlGetAttr, 
            name = "href") %>% 
    head
```

```{r}
mmu00010 <- xmlParse("/home/yincy/git/Data/KEGG/pathways/mouse/mmu00010.xml")

mmu00010 %>% xmlRoot()
entries <- getNodeSet(doc = xmlRoot(mmu00010), 
                       path = "/pathway/entry")

relations <- getNodeSet(doc = xmlRoot(mmu00010), 
                         path = "/pathway/relation")

reactions <- getNodeSet(doc = xmlRoot(mmu00010), 
                        path = "/pathway/reaction")


entries_df <- sapply(entries[1:2], FUN = function(node){
    id = xmlGetAttr(node, name = "id") 
    name = xmlGetAttr(node, name = "name")
    type = xmlGetAttr(node, name = "type")
    reaction = xmlGetAttr(node, name = "reaction", default = "")
})

entry_parse <- function(nodes, ...){
    id = sapply(nodes, FUN = xmlGetAttr, name = "id")
    name = sapply(nodes, FUN = xmlGetAttr, name = "name")
    type = sapply(nodes, FUN = xmlGetAttr, name = "type")
    reaction = sapply(nodes, FUN = xmlGetAttr, name = "reaction", default = NA)
    
    df <- data.frame(entry_id = id, 
                     name = name, 
                     type = type, 
                     reaction = reaction)
    
    return(df)
}

entries_df <- entry_parse(nodes = entries)


relation_parse <- function(nodes, ...){
    entry1 = sapply(nodes, FUN = xmlGetAttr, name = "entry1")
    entry2 = sapply(nodes, FUN = xmlGetAttr, name = "entry2")
    type = sapply(nodes, FUN = xmlGetAttr, name = "type")
    subtype = sapply(nodes, FUN = function(node){
        xmlGetAttr(xmlChildren(node)[[1]], name = "name")
        })
    
    subtype_value = sapply(nodes, FUN = function(node){
        xmlGetAttr(xmlChildren(node)[[1]], name = "value")
    })
    
    df <- tibble(entry1 = entry1, 
                     entry2 = entry2, 
                     type = type, 
                     subtype = subtype, 
                     subtype_value = subtype_value)
    return(df)
}

relations_df <- relation_parse(nodes = relations)
```

```{r}
nm <- xmlParse("exampleData/eurofxref-hist.xml.gz")
nm %>% xmlRoot() %>% .[[3]] %>% .[[1]]
```

```{r}
nm %>% class()

xpathSApply(doc = nm, 
            path = "//Cube[@currency = 'USD']", 
            fun = xmlGetAttr, 
            name = "rate", 
            default = NA)

getNodeSet(doc = nm, path = "//Cube[@currency = 'USD']") %>% 
    sapply(FUN = xmlGetAttr, name = "rate")

xpathSApply(doc = mmu00010, path = "//entry", fun = xmlGetAttr, name = "name")
```


```{r}
root <- xmlParse("exampleData/eurofxref-hist.xml") %>% xmlRoot()
getNodeSet(root, 
           path = "//ns:Cube[@rate > 25 and position() = 2]", 
           namespaces = c(ns = "http://www.ecb.int/vocabulary/2002-08-01/eurofxref")) %>% 
  xmlSize()

rates <- getNodeSet(doc = root, 
           path = "//ns:Cube[@currency = 'JPY']", 
           namespaces = c(ns = "http://www.ecb.int/vocabulary/2002-08-01/eurofxref")) %>% 
  sapply(X = ., 
         FUN = xmlGetAttr, 
         name = "rate") 

currencies <- c("USD", "JPY", "SGD")
q <- sprintf(fmt = "//ns:Cube[@currency = '%s']/@rate", 
                      currencies)
ns = getDefaultNamespace(root)[[1]]$uri

exRates <- lapply(q, 
                  FUN = function(q){as.numeric(getNodeSet(root, path = q, namespaces = c(ns = ns)))})

exRates %>% as.data.frame(col.names = currencies)
```


```{r}
getNodeSet(kiva, "//lender[./uid = 'myron']")
```


XPath ignores white space (blank spaces and new lines) within a location step and between steps which allows us to format the expressions freely.  


# XPath axis
- `child`  
- `attribute`  
- `parent` or `..`  
- `self` or `.`  
- `descendant`  
- `descendant-or-self`  
- `ancestor`  
- `ancestor-or-self`  
- `following-sibling`  
- `preceding-sibling`  
- `namespace`  
- `following`: matches all nodes after the current node in terms of the document order.  
- `preceding`: matches all nodes before the current node in terms of the document order.  


# XPath node functions
- `node()` or `*`: matches any regular node, but not text, comments, attributes, and processing instructions.  
- `text()`: match text nodes.  
- `comment()`: match comments node.  
- `processing-instruction()`: match any processing instruction ndoes.  


# XPath boolean operators
- `=`  
- `!=`  
- `>`  
- `>=`  
- `<`  
- `<=`  


```{r}
doc <- htmlParse("/home/yincy/Downloads/XML/History of the United States public debt - Wikipedia.html")

readHTMLTable(doc = doc, which =  3)
```








